[{"content":"This post aims to delve into the details of inheritance relationships and the virtual keyword in C++ in order to revive memories blurred by using other languages.\nInheritance Unlike other object-oriented languages such as Java and C#, C++ allows you to specify access specifiers during inheritance.\n1 2 // syntax class Derived : \u0026lt;access_specifier\u0026gt; Parent This indicates how the elements of the parent class are to be acquired when inheriting from the parent class. Think of replacing the elements loosely specified in the access_specifier with those specified by the type for inheritance.\nLet\u0026rsquo;s look at three types of classes that inherit the following class and examine the characteristics of each.\n1 2 3 4 5 6 7 8 9 class Base { public: int pubInt = 1; private: int privInt = 2; protected: int protInt = 3; }; public Used to represent the is-a relationship. It follows the access specifier of the parent.\n1 2 3 4 5 6 7 8 9 10 class Pub : public Base // is-a { public: Pub() { pubInt = 1; // public //privInt = 2; // Cannot access parent class\u0026#39;s private protInt = 3; // protected } }; Therefore, external access is limited to the pubInt of the parent class specified as public.\n1 2 3 4 Pub* pub = new Pub(); cout \u0026lt;\u0026lt; pub-\u0026gt;pubInt \u0026lt;\u0026lt; endl; //cout \u0026lt;\u0026lt; pub-\u0026gt;privInt \u0026lt;\u0026lt; endl; //error: ‘int Base::privInt’ is private within this context //cout \u0026lt;\u0026lt; pub-\u0026gt;protInt \u0026lt;\u0026lt; endl; //error: ‘int Base::protInt’ is protected within this context private Used when representing the is-implemented-in-terms-of relationship (default in cpp). Private inheritance inherits the elements of the parent class that can be accessed less strictly than private (i.e., protected and public elements) as private.\n1 2 3 4 5 6 7 8 9 10 class Priv : private Base // is-implemented-in-terms-of { public: Priv() { pubInt = 1; // public -\u0026gt; private //privInt = 2; // Cannot access parent class\u0026#39;s private protInt = 3; // protected -\u0026gt; private } }; Therefore, external access is prevented to any elements of the parent class.\n1 2 3 4 Priv* priv = new Priv(); //cout \u0026lt;\u0026lt; priv-\u0026gt;pubInt \u0026lt;\u0026lt; endl; //error: ‘int Base::pubInt’ is inaccessible within this context //cout \u0026lt;\u0026lt; priv-\u0026gt;privInt \u0026lt;\u0026lt; endl; //error: ‘int Base::privInt’ is private within this context //cout \u0026lt;\u0026lt; priv-\u0026gt;protInt \u0026lt;\u0026lt; endl; //error: ‘int Base::protInt’ is protected within this context Furthermore, even if a new class inherits from this class, access to any elements of the great-grandparent class is still unavailable.\n1 2 3 4 5 6 7 8 class GrandChild : Priv { public: GrandChild() { // Unable to access any elements of Base } }; protected Same as the private specifier, it is used when representing the is-implemented-in-terms-of relationship. It inherits the parent class\u0026rsquo;s public elements as protected.\n1 2 3 4 5 6 7 8 9 10 class Prot : protected Base // is-implemented-in-terms-of { public: Prot() { pubInt = 1; // public -\u0026gt; protected //privInt = 2; // error: ‘int Base::privInt’ is private within this context protInt = 3; // protected } }; Therefore, external access is denied to any elements of the Base class.\n1 2 3 4 Prot* prot = new Prot(); //cout \u0026lt;\u0026lt; prot-\u0026gt;pubInt \u0026lt;\u0026lt; endl; //error: ‘int Base::pubInt’ is inaccessible within this context //cout \u0026lt;\u0026lt; prot-\u0026gt;privInt \u0026lt;\u0026lt; endl; //error: ‘int Base::privInt’ is private within this context //cout \u0026lt;\u0026lt; prot-\u0026gt;protInt \u0026lt;\u0026lt; endl; // error: ‘int Base::protInt’ is protected within this context Moreover, unlike private, when a class inherits from this, it\u0026rsquo;s possible to access the elements of the great-grandparent class.\n1 2 3 4 5 6 7 8 9 class GrandChild2 : Prot { public: GrandChild2() { pubInt = 1; // because it is specified protected protInt = 3; // because it is specified protected } }; casting The supported cast for each case is as follows.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int main() { // upcasting check Base *ptr1, *ptr2, *ptr3; ptr1 = new Pub(); //ptr2 = new Priv(); // error: ‘Base’ is an inaccessible base of ‘Priv’ //ptr3 = new Prot(); // error: ‘Base’ is an inaccessible base of ‘Prot’ // downcasting check Base* base = new Base(); Pub* pub_down = static_cast\u0026lt;Pub*\u0026gt;(base); // checked at compile-time. Doesn\u0026#39;t consider polymorphism // Pub* pub_down = dynamic_cast\u0026lt;Pub*\u0026gt;(base); // error because source type is not polymorphic // Priv* priv_down = static_cast\u0026lt;Priv*\u0026gt;(base); // error: ‘Base’ is an inaccessible base of ‘Priv’ // Prot* prot_down = static_cast\u0026lt;Prot*\u0026gt;(base); // error: ‘Base’ is an inaccessible base of ‘Prot’ delete ptr1, ptr2, ptr3, pub_down, base; return 0; } is-implemented-in-terms-of In general programming languages, the is-a relationship is represented using inheritance (in the case of C++, public inheritance) and the has-a relationship is modeled using composition (containment, aggregation). C++ introduces the is-implemented-in-terms-of term to indicate relationships between objects where one object uses another to function. Thus, in C++, is-implemented-in-terms-of can also be represented using composition. Then, what is the difference between has-a and is-implemented-in-terms-of? The distinction between the two relationships lies in their domain.\nThe has-a relationship is used to model application domains that we can easily recognize in real life into programming. For example, application domains like people, means of communication, and modes of transport are modeled through the has-a relationship. On the other hand, is-implemented-in-terms-of is used solely to indicate the realm of software implementation. Examples include buffers, mutexes, and search trees.\nC++ provides the flexibility for implementing has-a relationships using composition or non-public inheritance for is-implemented-in-terms-of relationships.\nSo, when should we implement a feature using non-public inheritance, and when should we use composition? It\u0026rsquo;s worth examining which approach is suitable by looking at examples of classes created using both methods.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 template \u0026lt;class T\u0026gt; class MyList { public: bool Insert( const T\u0026amp;, size_t index ); T Access( size_t index ) const; size_t Size() const; private: T* buf_; size_t bufsize_; }; template \u0026lt;class T\u0026gt; class MySet1 : private MyList\u0026lt;T\u0026gt; { public: bool Add( const T\u0026amp; ); // calls Insert() T Get( size_t index ) const; // calls Access() using MyList\u0026lt;T\u0026gt;::Size; //... }; template \u0026lt;class T\u0026gt; class MySet2 { public: bool Add( const T\u0026amp; ); // calls impl_.Insert() T Get( size_t index ) const; // calls impl_.Access() size_t Size() const; // calls impl_.Size(); //... private: MyList\u0026lt;T\u0026gt; impl_; }; Implementation with Inheritance vs. Composition As you can see from the above example, whatever can be done with a single composition can also be implemented with inheritance. So, why does C++ distinguish between is-implemented-in-terms-of and has-a?\nThe reason lies in that some features can be implemented with non-public inheritance but not with a single composition. Below are five items indicating when to use each method (roughly listed starting from the most common case).\nWhen access to protected members is needed. This usually refers to the need to call protected methods (or constructors). When there is a need to override virtual functions. If the base class has a pure virtual function, composition cannot be used. When an implementation needs to be constructed (or destroyed) before (or after) another implementation. If multiple implementations depend on one another such that a specific implementation\u0026rsquo;s lifecycle must cover all others, critical sections like locks, data transactions, etc., it becomes crucial. When sharing a virtual base class or modification is needed when creating a virtual base class. Lastly, despite being distant from is-implemented-in-terms-of, non-public inheritance possesses another characteristic that composition alone cannot achieve.\nWhen \u0026lsquo;restricted polymorphism\u0026rsquo; is required. Cases where the Liskov substitution principle needs to be applied only to certain pieces of code. Public inheritance guarantees Liskov substitution always, while non-public inheritance can denote a more limited IS-A relationship. Although from the outside, non-public inheritance may not seem polymorphic at all (D is not a B), situations might arise in member functions or friend classes where polymorphism is needed. Let\u0026rsquo;s revisit the MySet and MyList code. In this case:\nMyList has no protected members. MyList is not an abstract class. MySet has no other classes inherited except MyList. MyList does not inherit any virtual base class. MySet is not MyList; MySet is-not-a MyList As none of the above five situations apply, it\u0026rsquo;s best to implement it using composition rather than inheritance. Using inheritance can expose unnecessary information to subclasses and create unnecessary dependencies.\nWith a thorough review, it seems that C++ offers a variety of ways in implementing object relationships compared to other languages. However, it is not easy to understand, and it seems that there are many aspects to consider to avoid violating the principles of object-oriented programming.\nNote: The source of this translation is present in the original document.\n","date":"2024-03-08T11:12:45+09:00","image":"https://sangho0n.github.io/en/p/c-inheritance-and-the-virtual-keyword/img/cpp.svg","permalink":"https://sangho0n.github.io/en/p/c-inheritance-and-the-virtual-keyword/","title":"C++ Inheritance and the virtual Keyword"},{"content":"Based on the official documentation, this document provides insights into Unreal\u0026rsquo;s implementation of various smart pointers used in C++. The provided classes include Shared Pointers, Weak Pointers, Unique Pointers, and an additional type known as Shared Reference. Due to separate memory management for UObjects, instances of classes inherited from UObject cannot be wrapped with smart pointers (memory is reclaimed differently, following the RAII pattern).\nTypes of Pointers Type Usage TSharedPtr A shared pointer owns the encapsulated object. It prevents the object from being destroyed while it is owned externally, and ultimately governs the destruction of the object when the count of shared pointers (or references) owning it becomes 0. A shared pointer can exist even when it doesn\u0026rsquo;t encapsulate an object. You can create a shared reference anytime the encapsulated object is not null. TSharedRef Similar to a shared pointer, but the encapsulated object cannot be null. Since null is impossible, it can be converted to a shared pointer anytime, ensuring that the object being pointed to is always valid. It is used when explicit ownership of an object is desired or when ensuring that an object is not null. TWeakPtr Similar to a shared pointer, but it does not own the object, allowing it to not affect the reference\u0026rsquo;s lifecycle. It can be useful for breaking reference cycles, but accessing an object simultaneously can become null without warning. If safe access is desired, it\u0026rsquo;s recommended to convert it to a shared pointer first. TUniquePtr A unique pointer exclusively owns the object. Although ownership can be transferred, it cannot be shared. Trying to copy a unique pointer results in a compile error in all cases. When the scope is exited, the owned object is automatically released from memory. 1) Refers to a situation where two or more objects reference each other, preventing each other from being released because the reference count never reaches 0, potentially leading to memory leaks.\nBenefits Benefit Description Prevention of Memory Leaks Automatically deallocates objects, preventing memory leaks. Weak References Solves circular reference issues and prevents dangling pointer problems. Optional Thread Safety Additional code can be added for thread safety when needed (comes with overhead). Runtime Safety Shared references cannot be null and can release references at any time, ensuring runtime safety. Intentional Conveyance Easily distinguishes between owners and observers. Memory Benefits Performs all functions with just twice the size of a pointer variable in C++ (based on 64-bit systems; including 16 bytes for reference control). However, a unique pointer has the same size as a C++ pointer. 1) Owners own objects and manage their lifecycles. They can own and release objects using shared pointers and unique pointers when they are no longer needed. Observers reference objects but do not own them (weak pointers). When the owner deletes the object, the observer should become null.\nHelper Classes and Functions Helper Description Classes TSharedFromThis Inheriting from TSharedFromThis adds AsShared and SharedThis methods to the class. These methods help obtain a TSharedRef for the object. Functions MakeShared and MakeShareable MakeShared creates a TSharedPtr from a regular C++ pointer. It allocates a new object instance and a reference controller in a single memory block. The object must have a public constructor. MakeShareable is also used to create a TSharedPtr from a C++ pointer. It works even if the object\u0026rsquo;s constructor is private. It allows ownership of objects not created by oneself and can provide custom logic upon destruction. This flexibility can lead to additional programming practices compared to MakeShared but comes with additional overhead. StaticCastSharedRef and StaticCastSharedPtr Utility functions supporting static casting (usually downcasting). ConstCastSharedRef and ConstCastSharedPtr Return a const to mutable object for each reference and pointer type variable. Example of using MakeShareable to add additional logic to the destructor:\n1 2 3 4 5 6 TSharedPtr\u0026lt;FOnlineSession\u0026gt; SharedPtr = MakeShareable(new FOnlineSession(), [](FOnlineSession* ObjToDelete)-\u0026gt; void { // Custom destructor implementation ObjToDelete-\u0026gt;PerformAdditionalCleanup(); delete ObjToDelete; }); Detailed Implementation Unreal\u0026rsquo;s smart pointers library is implemented with both functionality and efficiency in mind.\nSpeed While smart pointers are beneficial in high-level systems like resource management and tool programming, they are not suitable for low-level engine code such as rendering due to performance overhead compared to raw C++ pointers.\nUnreal\u0026rsquo;s smart pointers library provides the following performance advantages:\nAll operations are performed in constant time. (In shipping builds) Dereferencing in most smart pointers is as fast as raw C++ pointers. Copying a smart pointer does not require new memory allocation. Thread-safe smart pointers do not require locking. However, there are some drawbacks as well:\nCreating and copying new smart pointers have overhead compared to raw C++ pointers. Managing reference counts adds computational overhead to basic operations. Some smart pointers require more memory than raw C++ pointers. Reference controllers require two heap memory allocations. Using MakeShared can eliminate the second memory allocation. Intrusive Accessors By inheriting TSharedFromThis, a class can obtain accessors for shared pointers that reference it. This allows objects to know which shared pointers are referencing them.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class FRegistryObject; class FMyBaseClass: public TSharedFromThis\u0026lt;FMyBaseClass\u0026gt; { virtual void RegisterAsBaseClass(FRegistryObject* RegistryObject) { // Access a shared reference to \u0026#39;this\u0026#39;. TSharedRef\u0026lt;FMyBaseClass\u0026gt; ThisAsSharedRef = AsShared(); RegistryObject-\u0026gt;Register(ThisAsSharedRef); } }; class FMyDerivedClass : public FMyBaseClass { virtual void Register(FRegistryObject* RegistryObject) override { TSharedRef\u0026lt;FMyDerivedClass\u0026gt; AsSharedRef = SharedThis(this); RegistryObject-\u0026gt;Register(ThisAsSharedRef); } }; class FRegistryObject { void Register(TSharedRef\u0026lt;FMyBaseClass\u0026gt;); }; As mentioned, by inheriting TSharedFromThis, a class can use AsShared and SharedThis methods to obtain a shared reference of its instance. Note that the SharedRef method returns a shared reference to the originally specified type in TSharedFromThis, while SharedThis returns a shared reference with the type of \u0026rsquo;this\u0026rsquo;. It is recommended to use the shared pointer of the base class directly when passing shared pointers in method parameters.\nBe cautious when using AsShared and SharedThis in constructors, as it may lead to crashes or asserts.\nType Casting Unreal\u0026rsquo;s smart pointers library allows casting similar to raw C++ pointers.\nUp Casting: Implicitly performed, allowing a base class pointer to be automatically converted to a derived class pointer. Const Casting: Use ConstCastSharedPtr/Ref methods for const casting. Static Casting: Use StaticCastSharedPtr/Ref methods for static casting (usually downcasting). Dynamic Casting: Dynamic casting is not supported due to the absence of runtime type information (RTTI). 1 2 3 4 5 6 TSharedPtr\u0026lt;FDragDropOperation\u0026gt; Operation = DragDropEvent.GetOperation(); // Validating that the FDragDropOperation is an FAssetDragDropOp through other means... // Casting with StaticCastSharedPtr TSharedPtr\u0026lt;FAssetDragDropOp\u0026gt; DragDropOp = StaticCastSharedPtr\u0026lt;FAssetDragDropOp\u0026gt;(Operation); Thread Safety By default, smart pointers are only safe in single-threaded environments. If you want a thread-safe version, you can use classes like:\nTSharedPtr\u0026lt;T, ESPMode::ThreadSafe\u0026gt; TSharedRef\u0026lt;T, ESPMode::ThreadSafe\u0026gt; TWeakPtr\u0026lt;T, ESPMode::ThreadSafe\u0026gt; TSharedFromThis\u0026lt;T, ESPMode::ThreadSafe\u0026gt; These classes perform atomic operations on reference counts, which makes them slightly slower than default classes but operation is very similar to raw C++ pointers.\nReading and copying operations are always thread-safe. Writing and reset operations require synchronization for safety. Comments When passing shared pointers/references as method arguments, there is overhead due to reference counting and dereferencing. If possible, pass by const \u0026amp;. Shared pointers allow forward declaration of incomplete types. As mentioned, smart pointers and garbage collection in C++ (UObject Handling) are two separate memory management systems. ","date":"2024-03-05T17:31:11+09:00","image":"https://sangho0n.github.io/en/p/unreal-smart-pointers/img/unreal.svg","permalink":"https://sangho0n.github.io/en/p/unreal-smart-pointers/","title":"Unreal Smart Pointers"},{"content":"Sorting algorithms should be chosen based on criteria such as time complexity in the best, average, and worst cases, as well as memory usage and stability.\nThe speed of sorting algorithms based on comparisons cannot be faster than O(nlog(n)) in the worst case.\nList of Sorting Algorithms Covered in this Post Selection Sort Insertion Sort Bubble Sort Heap Sort Quick Sort Merge Sort Radix Sort Selection Sort One of the simplest algorithms. Since it is an in-place algorithm, it is suitable for environments where copying operations are very slow.\nAt each step, the array is scanned once, selecting the minimum (maximum) value among the unsorted elements and swapping it with the front element.\nAfter each step, the number of unsorted elements is reduced by one, and the same operation is repeated for the reduced array.\nIn-Place. Unstable.\nTime Complexity Case Complexity Best O(n^2) Worst O(n^2) Average O(n^2) Insertion Sort Divides one array into a sorted array and an unsorted array, increasing the size of the sorted array step by step and decreasing the size of the unsorted array.\nAn unsorted array\u0026rsquo;s front element is compared sequentially with the elements of the sorted array and inserted at the appropriate position.\nIn-Place. Stable.\nTime Complexity Case Complexity Best (Already sorted) O(n) Worst O(n^2) Average O(n^2) Bubble Sort At each step, the array is linearly searched, comparing adjacent elements and performing swap operations.\nIn-place. Stable.\nTime Complexity Case Complexity Best O(n^2) Worst O(n^2) Average O(n^2) Heap Sort A method of sorting using a max heap or min heap. It is possible to use a separate heap or make the given array a heap (In-place).\nThe operations of inserting/deleting elements in the heap are O(logn) (height of the heap), and these operations are repeated for the number of elements (twice; making a Heap + pulling elements one by one), so the total time complexity is O(nlogn).\nIn-Place. Unstable.\nTime Complexity Case Complexity Best O(nlogn) Worst O(nlogn) Average O(nlogn) Quick Sort Divides the array based on the pivot value into smaller values on the left and larger values on the right.\nFor each divided array, Quick Sort is performed iteratively until it cannot be divided further.\nIf the pivot is optimally selected at every moment, the given array is precisely divided in half every time. The worst case occurs when the pivot is consistently selected as the minimum (or maximum) value.\nIn-Place. Unstable.\nTime Complexity Case Complexity Best O(nlogn) Worst O(n^2) Average O(nlogn) Merge Sort One of the divide and conquer algorithms. The array is divided in half, and Merge Sort is performed on each divided array. Then, the sorted arrays are merged to obtain one large sorted array.\nUnlike other sorting algorithms, it has O(n) level of space complexity even in the best case.\nFor the purpose of optimizing the divided array, you can mix Merge Sort with another sorting algorithm (such as Insertion Sort) that is not Merge Sort (this may result in instability).\nnot In-Place. Stable.\nTime Complexity Case Complexity Best O(nlogn) Worst O(nlogn) Average O(nlogn) Radix Sort Unlike the previous algorithms, a sorting algorithm that operates without comparisons. Since the numbers are sorted based on digits, the digits must be sortable in lexicographical order.\nA kind of bucket sort.\nnot In-Place. Stable\nTime Complexity Let n be the number of digits to be sorted, d be the maximum number of digits, and k be the number of buckets (0~9 for numbers).\nBest, worst, and average cases are all O(d(n + k))\n","date":"2024-02-26T11:49:35+09:00","image":"https://sangho0n.github.io/en/p/summary-of-sorting-algorithms/img/algorithm_hu8666b0214ef6ef8b40207752073739fc_14421_120x120_fill_box_smart1_3.png","permalink":"https://sangho0n.github.io/en/p/summary-of-sorting-algorithms/","title":"Summary of Sorting Algorithms"},{"content":"\nStarting from Unreal Engine 5, the existing input mapping system has been deprecated. Let\u0026rsquo;s take a look at the Enhanced Input system that replaces it.\nTo effectively support complex input processing and runtime control remapping, the concept introduced from UE5 is Enhanced Input. It is an upgraded version of UE4\u0026rsquo;s default input system, providing backward compatibility as well. Not only does it handle input data processing, but it also allows functionalities such as radial dead zone, composite actions, combo attacks, etc., to be implemented in an asset-based environment.\nKey Concepts The Enhanced Input system has four key concepts:\nInput Action: Acts as a communication channel between the Enhanced Input system and project code. An input action can report up to three independent axis (floating point) values separate from the input that triggered itself. Input Mapping Context: Responsible for mapping user input to input actions. It can be dynamically added or removed for individual users and can have priorities. By applying one or more input mapping contexts to a player and assigning priorities, conflicts can be resolved even if multiple actions are triggered by the same input. e.g., when a button opens a door and another button opens a bag\nAdditionally, the following two concepts are elements that make input processing more flexible.\nModifier: Used to refine input values. It can apply a dead zone to ignore small movements or make input values smoother, among other operations. Modifiers that are already defined can be used, or developers can define their custom modifiers. Trigger: Determines whether to activate the input action based on processed data from modifiers or the result of other input actions. Input Actions Connects the Enhanced Input system with project code. To trigger an input action, you must add the input action to an input mapping context and register the input mapping context in the local player\u0026rsquo;s Enhanced Input Local Player Subsystem.\nTo make a Pawn react to the triggered input action, you need to control it using Blueprints or C++.\n1 2 3 4 5 6 7 8 9 10 11 12 void AMyCharacter::SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) { Super::SetupPlayerInputComponent(PlayerInputComponent); UEnhancedInputComponent* EnhancedInputComponent = CastChecked\u0026lt;UEnhancedInputComponent\u0026gt;(PlayerInputComponent); EnhancedInputComponent-\u0026gt;BindAction(MyAction, ETriggerEvent::Triggered, this, \u0026amp;AMyCharacter::MyAction); } void AMyCharacter::MyAction(const FInputActionValue\u0026amp; Value) { // do sth } Input Mapping Contexts In an input mapping context, you can map inputs to input actions. Once a mapping is completed, the context can be added or removed anytime to the local player\u0026rsquo;s Enhanced Input Local Player Subsystem.\n1 2 3 4 5 6 7 8 9 10 11 12 // do sth ... APlayerController* PlayerController = CastChecked\u0026lt;APlayerController\u0026gt;(GetController()); if (UEnhancedInputLocalPlayerSubsystem* Subsystem = ULocalPlayer::GetSubsystem\u0026lt;UEnhancedInputLocalPlayerSubsystem\u0026gt;(PlayerController-\u0026gt;GetLocalPlayer())) { Subsystem-\u0026gt;ClearAllMappings(); UInputMappingContext* NewMappingContext = NewCharacterControl-\u0026gt;InputMappingContext; if (NewMappingContext) { Subsystem-\u0026gt;AddMappingContext(NewMappingContext, 0); } } // do sth ... Modifier A modifier is a pre-processor that can adjust input values before sending them through the trigger. The Unreal Engine provides the following modifiers by default:\nTo create a new modifier, you need to create a class that inherits from the InputModifier class. And override the Modify Raw function. Directional Input One example of using modifiers effectively is implementing 2D directional input using a single input action. When creating a Third-Person Template project, examine the IA_Move and IMC_Default configurations as follows:\nKey Input Direction Scalar Value Modifier Desired Direction Vector w Up 1 Swizzle Input Axis Value (1, 0, 0) s Down 1 Swizzle Input Axis Value, Negate (-1, 0, 0) a Left 1 Negate (0, -1, 0) d Right 1 - (0, 1, 0) Looking at parts of the declaration and implementation of the UInputModifierSwizzleAxis class:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 UCLASS(NotBlueprintable, MinimalAPI, meta = (DisplayName = \u0026#34;Swizzle Input Axis Values\u0026#34;)) class UInputModifierSwizzleAxis : public UInputModifier { GENERATED_BODY() public: UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Settings) EInputAxisSwizzle Order = EInputAxisSwizzle::YXZ; protected: virtual FInputActionValue ModifyRaw_Implementation(const UEnhancedPlayerInput* PlayerInput, FInputActionValue CurrentValue, float DeltaTime) override; virtual FLinearColor GetVisualizationColor_Implementation(FInputActionValue SampleValue, FInputActionValue FinalValue) const override; }; FInputActionValue UInputModifierSwizzleAxis::ModifyRaw_Implementation(const UEnhancedPlayerInput* PlayerInput, FInputActionValue CurrentValue, float DeltaTime) { FVector Value = CurrentValue.Get\u0026lt;FVector\u0026gt;(); switch (Order) { case EInputAxisSwizzle::YXZ: Swap(Value.X, Value.Y); break; // other cases... } return FInputActionValue(CurrentValue.GetValueType(), Value); } With the default Order being YXZ, passing through a scalar value of 1 through the modifier results in a value of (1.0f, 0.0f, 0.0f). Setting up the modifier as described in the table allows scalar values to be converted into the desired direction vectors.\nTrigger The trigger verifies processed values from modifiers and other input actions to determine whether the input action should be activated. However, the Chord Action trigger is an exception and is triggered through another input action. The images below showcase the default triggers.\nThere are three trigger types: Explicit, Implicit, and Blocker.\nExplicit: Input succeeds when the trigger condition is met. Implicit: Input succeeds if the trigger condition is met along with all implicit trigger types. Blocker: Input fails when the trigger condition is met. The table below shows the type of triggers based on their classes:\nTrigger Class (cpp) Type UInputTrigger(default) Explicit UInputTriggerCombo Implicit UInputTriggerChordAction Implicit UInputTriggerChordBlocker Blocker After processing user input, the trigger can return one of three states:\nNone: The conditions were not met, and the trigger failed. Ongoing: The conditions were partially met and the trigger is still in progress but has not yet succeeded. Triggered: All input trigger conditions were met, and the input trigger succeeded. By inheriting the InputTrigger class or the InputTriggerTimedBase class, you can create custom triggers. The InputTriggerTimedBase class checks if input has been sustained for a certain period and returns the Ongoing state during that time. However, as the InputTriggerTimedBase class does not return Triggered even if the conditions are met, when creating a new trigger by inheriting it, you must override the GetTriggerType and UpdateState methods to return the desired states.\n","date":"2024-02-14T17:44:19+09:00","image":"https://sangho0n.github.io/en/p/unreal-enhanced-input/img/unreal.svg","permalink":"https://sangho0n.github.io/en/p/unreal-enhanced-input/","title":"Unreal Enhanced Input"},{"content":"This content is based on lectures by Lee Eunwoo and documents compiled by other developers.\nFor detailed and accurate information, please refer to the above links.\nSeries\nUnreal GAS Overview \u0026lt;- Current Post Getting Started with Unreal GAS Gameplay Ability System A framework that provides actor abilities and interactions among actors through abilities. Advantages Flexibility, Scalability: Easily adaptable to various complex game designs. Modular System: Minimizes dependencies for each function. Network Support Data-Driven Design Maturity: Games like Fortnite already utilize it. Disadvantages Learning Curve Overhead in small projects Suitable for creating large-scale RPGs and multiplayer games.\nComponents Gameplay Ability: Implementation of character abilities based on cost and cooldown (optional). Attributes: Manipulation of actor characteristics. Gameplay Effects: Changes in actor states triggered by ability activation. Gameplay Tags: Tagging actors. Gameplay Cue: Visual effects. Replication for all of the above. GAS in Multiplayer Games The GAS plugin supports client-side prediction (ability activation and effects application without server authorization) as follows:\nAbility Activation Animation Montage Playback Attribute Changes Gameplay Tagging Gameplay Cue Execution Movement control through CharacterMovementComponent and RootMotionSource functions. Blueprint vs C++ GAS should be implemented using C++, but implementation via Blueprints is possible for GameplayAbilities and GameplayEffects.\n","date":"2024-02-14T13:53:44+09:00","image":"https://sangho0n.github.io/en/p/unreal-gas-overview/img/unreal.svg","permalink":"https://sangho0n.github.io/en/p/unreal-gas-overview/","title":"Unreal GAS Overview"},{"content":"Please translate only the values of title, tags, categories, and series into English without altering the structure. If not, errors like the following may occur: failed to unmarshal YAML: yaml: line 10: could not find expected \u0026lsquo;:\u0026rsquo;\nAfter this, a Korean document written in Markdown including the header will be provided. Please translate its header and body into English.\ntitle: \u0026ldquo;Unreal GAS Introduction\u0026rdquo; date: 2024-03-18T15:58:25+09:00 image: img/unreal.svg\ntags: [\u0026ldquo;Unreal\u0026rdquo;, \u0026ldquo;언리얼\u0026rdquo;, \u0026ldquo;UE\u0026rdquo;, \u0026ldquo;GAS\u0026rdquo;, \u0026ldquo;Ability\u0026rdquo;] categories: [\u0026ldquo;Unreal\u0026rdquo;] series: [\u0026ldquo;Gameplay Ability System (GAS)\u0026rdquo;]\nBased on lectures by Lee Deuk-Woo and documentation by other developers.\nRefer to the given links for detailed and accurate information.\nSeries:\nUnreal GAS Overview Unreal GAS Introduction \u0026lt;- Current post In this post, we will explore the implementation of actor movement using three methods to understand the usage of the GAS framework and examine the differences between each method.\nActor Function Extension Using the Game Ability System Using Game Ability System with Gameplay Tags The actor chosen for this demonstration is a fountain, and the movement involves a 3-second stationary rotation/stop as the base.\nActor Function Extension Implementation without the GAS framework using URotatingMovementComponent directly.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 UCLASS() class ARENABATTLEGAS_API AABGASFountain : public AABFountain { GENERATED_BODY() public: AABGASFountain(); protected: virtual void PostInitializeComponents() override; virtual void BeginPlay() override; virtual void TimerAction(); protected: UPROPERTY(VisibleAnywhere, Category=Movement) TObjectPtr\u0026lt;URotatingMovementComponent\u0026gt; RotatingMovement; UPROPERTY(EditAnywhere, Category=Timer) float ActionInterval; FTimerHandle ActionTimer; }; void AABGASFountain::BeginPlay() { Super::BeginPlay(); GetWorld()-\u0026gt;GetTimerManager().SetTimer(ActionTimer, this, \u0026amp;AABGASFountain::TimerAction, ActionInterval, true, 0.0f); } void AABGASFountain::TimerAction() { if(!RotatingMovement-\u0026gt;IsActive()) { RotatingMovement-\u0026gt;Activate(); } else { RotatingMovement-\u0026gt;Deactivate(); } } Using the Game Ability System To implement movement using the GAS framework, it is essential to understand the following two concepts:\nAbility System Component Game Ability Ability System Component Manages the Gameplay Ability System Only one can be attached per actor Actors can trigger Gameplay Abilities through this component Allows for interaction between actors with this component under the Game Ability System Game Ability An action that can be registered with the Ability System Component to be triggered Activation process: Registration with Ability System Component: AbilitySystemComponent-\u0026gt;GiveAbility() Activating the action: AbilitySystemComponent-\u0026gt;TryActivateAbility() Within the activated ability, requirements are implemented using SpecHandle, ActorInfo, ActivationInfo Key methods: CanActivateAbility ActivateAbility CancelAbility EndAbility Implementing the same movement as before using these two concepts would look like this:\nCreate an Ability class that inherits from GameplayAbility 1 2 3 4 5 6 7 8 9 UCLASS() class ARENABATTLEGAS_API UABGA_Rotate : public UGameplayAbility { GENERATED_BODY() virtual void ActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, const FGameplayEventData* TriggerEventData) override; virtual void CancelAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, bool bReplicateCancelAbility) override; }; Attach components to the actor and implement the interface 1 2 3 4 5 6 7 8 9 10 UCLASS() class ARENABATTLEGAS_API AABGASFountain : public AABFountain, public IAbilitySystemInterface { GENERATED_BODY() public: AABGASFountain(); virtual UAbilitySystemComponent* GetAbilitySystemComponent() const override; //... }; Register and trigger abilities with the attached components 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 void AABGASFountain::PostInitializeComponents() { Super::PostInitializeComponents(); AbilitySystemComponent-\u0026gt;InitAbilityActorInfo(this, this); FGameplayAbilitySpec RotateSpec(UABGA_Rotate::StaticClass()); AbilitySystemComponent-\u0026gt;GiveAbility(RotateSpec); } void AABGASFountain::TimerAction() { if(auto RotateSpec = AbilitySystemComponent-\u0026gt;FindAbilitySpecFromClass(UABGA_Rotate::StaticClass())) { if(!RotateSpec-\u0026gt;IsActive()) { AbilitySystemComponent-\u0026gt;TryActivateAbility(RotateSpec-\u0026gt;Handle); } else { AbilitySystemComponent-\u0026gt;CancelAbilityHandle(RotateSpec-\u0026gt;Handle); } } } Using Game Ability System with Gameplay Tags When using the Game Ability System without Gameplay Tags, the full advantages of the GAS framework may not be utilized. First, let\u0026rsquo;s understand what Gameplay Tags are.\nGameplay Tags FGameplayTag represents a name registered hierarchically like Parent.Child.Grandchild.... These tags are registered by the GameplayTagManager. Using these tags, classes can be categorized, and states can be effectively tracked.\nBy checking if an object has a Gameplay Tag, the system can replace using bool values or enums with condition statements to track states.\nGAS framework is very friendly with Gameplay Tags. Since UAbilitySystemComponent implements IGameplayTagAssetInterface, tags can be directly assigned to Ability System Components and abilities can be managed effectively with Gameplay Tags.\nBy using Gameplay Tags, the same requirements can be implemented as shown below.\nCreate tags as needed 1 2 3 4 5 // DefaultGameplayTags.ini [/Script/GameplayTags.GameplayTagsSettings] //... +GameplayTagList=(Tag=\u0026#34;Actor.Action.Rotate\u0026#34;,DevComment=\u0026#34;\u0026#34;) +GameplayTagList=(Tag=\u0026#34;Actor.State.IsRotating\u0026#34;,DevComment=\u0026#34;\u0026#34;) Define macros to easily access tags 1 2 3 // ABGameplayTag.h #define ABTAG_ACTOR_ROTATE FGameplayTag::RequestGameplayTag(FName(\u0026#34;Actor.Action.Rotate\u0026#34;)) #define ABTAG_ACTOR_ISROTATING FGameplayTag::RequestGameplayTag(FName(\u0026#34;Actor.State.IsRotating\u0026#34;)) Register tags in Gameplay Abilities 1 2 3 4 5 6 UABGA_Rotate::UABGA_Rotate() { AbilityTags.AddTag(ABTAG_ACTOR_ROTATE); // Activation adds the following tag ActivationOwnedTags.AddTag(ABTAG_ACTOR_ISROTATING); } Register and activate abilities based on tags 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // ABGASFountain.h UPROPERTY(EditAnywhere, Category=GAS) TArray\u0026lt;TSubclassOf\u0026lt;UGameplayAbility\u0026gt;\u0026gt; Abilities; // Implementation void AABGASFountain::PostInitializeComponents() { Super::PostInitializeComponents(); AbilitySystemComponent-\u0026gt;InitAbilityActorInfo(this, this); for (auto Element : Abilities) { FGameplayAbilitySpec Spec(Element); AbilitySystemComponent-\u0026gt;GiveAbility(Spec); } } void AABGASFountain::TimerAction() { FGameplayTagContainer TargetTag(ABTAG_ACTOR_ROTATE); if(!AbilitySystemComponent-\u0026gt;HasMatchingGameplayTag(ABTAG_ACTOR_ISROTATING)) { AbilitySystemComponent-\u0026gt;TryActivateAbilitiesByTag(TargetTag); } else { AbilitySystemComponent-\u0026gt;CancelAbilities(\u0026amp;TargetTag); } } Following this, create a Blueprint class that inherits from the AABGASFountain cpp class and add the desired activities to the Abilities array in the Details panel.\nSummary Implemented rotating fountain using three methods:\nActor Function Extension GAS: Creating a new class (ability) to separate functionality from the actor GAS + Gameplay Tags: Using tags to remove dependencies between actors and abilities Advantages of using GAS and Gameplay Tags together:\nMinimize the role of the actor Reduce dependencies, making maintenance easier and increasing reusability Improved scalability and ease of collaboration with other departments ","date":"2024-02-14T13:53:44+09:00","image":"https://sangho0n.github.io/en/p/unreal-gas-overview/img/unreal.svg","permalink":"https://sangho0n.github.io/en/p/unreal-gas-overview/","title":"Unreal GAS Overview"}]