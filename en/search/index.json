[{"content":"This lecture by 이득우 and this document organized by another developer for reference.\nFor detailed and accurate information, please refer to the links above.\nSeries\nIntroduction to Unreal GAS Starting Unreal GAS \u0026lt;- Current Post In this post, while implementing the movement of an actor through three methods, we will explore how to use the GAS framework, and examine the differences between each method.\nActor Function Extension Game Ability System Usage Game Ability System + Gameplay Tag Usage For the actor, a fountain, the movement is created based on a 3-second stationary rotation/stop.\nActor Function Extension Implemented using URotatingMovementComponent directly without the GAS framework.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 UCLASS() class ARENABATTLEGAS_API AABGASFountain : public AABFountain { GENERATED_BODY() public: AABGASFountain(); protected: virtual void PostInitializeComponents() override; virtual void BeginPlay() override; virtual void TimerAction(); protected: UPROPERTY(VisibleAnywhere, Category=Movement) TObjectPtr\u0026lt;URotatingMovementComponent\u0026gt; RotatingMovement; UPROPERTY(EditAnywhere, Category=Timer) float ActionInterval; FTimerHandle ActionTimer; }; void AABGASFountain::BeginPlay() { Super::BeginPlay(); GetWorld()-\u0026gt;GetTimerManager().SetTimer(ActionTimer, this, \u0026amp;AABGASFountain::TimerAction, ActionInterval, true, 0.0f); } void AABGASFountain::TimerAction() { if(!RotatingMovement-\u0026gt;IsActive()) { RotatingMovement-\u0026gt;Activate(); } else { RotatingMovement-\u0026gt;Deactivate(); } } Game Ability System Usage To implement the movement using the GAS framework, you need to first understand the following two concepts:\nAbility System Component Game Ability Ability System Component Manages the Game Play Ability System Only one can be attached per actor Actors can trigger Gameplay Abilities through this Enables interaction between actors with this component by the Game Ability System Game Ability An action that can be registered in the Ability System Component for activation Activation process Registration in Ability System Component : AbilitySystemComponent-\u0026gt;GiveAbility() Activation of ability : AbilitySystemComponent-\u0026gt;TryActivateAbility() Use SpecHandle, ActorInfo, ActivationInfo within the ability to implement requirements Key methods CanActivateAbility ActivateAbility CancelAbility EndAbility Implementing the same movement as the very beginning using the above two concepts will look like this:\nCreate an ability class by inheriting from GameplayAbility 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 UCLASS() class ARENABATTLEGAS_API UABGA_Rotate : public UGameplayAbility { GENERATED_BODY() virtual void ActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, const FGameplayEventData* TriggerEventData) override; virtual void CancelAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, bool bReplicateCancelAbility) override; }; void UABGA_Rotate::ActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, const FGameplayEventData* TriggerEventData) { Super::ActivateAbility(Handle, ActorInfo, ActivationInfo, TriggerEventData); if(auto Avatar = ActorInfo-\u0026gt;AvatarActor.Get()) { if(auto RotatingMovement = Avatar-\u0026gt;GetComponentByClass(URotatingMovementComponent::StaticClass())) { RotatingMovement-\u0026gt;Activate(); } } } void UABGA_Rotate::CancelAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, bool bReplicateCancelAbility) { Super::CancelAbility(Handle, ActorInfo, ActivationInfo, bReplicateCancelAbility); // omitted } Attach components to the actor and implement the interface 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 UCLASS() class ARENABATTLEGAS_API AABGASFountain : public AABFountain, public IAbilitySystemInterface { GENERATED_BODY() public: AABGASFountain(); virtual UAbilitySystemComponent* GetAbilitySystemComponent() const override; // pure virtual //... UPROPERTY(VisibleAnywhere, Category=Ability) TObjectPtr\u0026lt;UAbilitySystemComponent\u0026gt; AbilitySystemComponent; UPROPERTY(VisibleAnywhere, Category=Ability) TObjectPtr\u0026lt;URotatingMovementComponent\u0026gt; RotatingMovement; UPROPERTY(EditAnywhere, Category=Timer) float ActionInterval; FTimerHandle ActionTimer; }; UAbilitySystemComponent* AABGASFountain::GetAbilitySystemComponent() const { return AbilitySystemComponent; } Register and trigger abilities with attached components 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 void AABGASFountain::PostInitializeComponents() { Super::PostInitializeComponents(); AbilitySystemComponent-\u0026gt;InitAbilityActorInfo(this, this); FGameplayAbilitySpec RotateSpec(UABGA_Rotate::StaticClass()); AbilitySystemComponent-\u0026gt;GiveAbility(RotateSpec); } void AABGASFountain::TimerAction() { if(auto RotateSpec = AbilitySystemComponent-\u0026gt;FindAbilitySpecFromClass(UABGA_Rotate::StaticClass())) { if(!RotateSpec-\u0026gt;IsActive()) { AbilitySystemComponent-\u0026gt;TryActivateAbility(RotateSpec-\u0026gt;Handle); } else { AbilitySystemComponent-\u0026gt;CancelAbilityHandle(RotateSpec-\u0026gt;Handle); } } } Game Ability System + Gameplay Tag Usage When using the Game Ability System without Gameplay Tags, the full potential of the GAS framework cannot be utilized. Let\u0026rsquo;s first understand what Gameplay Tags are.\nGameplay Tags FGameplayTag refers to a name registered in a hierarchical form like Parent.Child.Grandchild.... These tags are registered by the GameplayTagManager. By using these tags, classes can be classified and states can be effectively tracked.\nInstead of using bool values or enums to track states, the presence of Gameplay Tags on an object can be used to replace them, making state checking more efficient.\nMoreover, using Gameplay Tags allows for implementing the same requirements without explicit information about Gameplay Ability classes in the actor class, leading to lower code dependencies.\nBy using Gameplay Tags, the same requirements can be implemented as follows:\nCreate tags 1 2 3 4 5 // DefaultGameplayTags.ini [/Script/GameplayTags.GameplayTagsSettings] //... +GameplayTagList=(Tag=\u0026#34;Actor.Action.Rotate\u0026#34;,DevComment=\u0026#34;\u0026#34;) +GameplayTagList=(Tag=\u0026#34;Actor.State.IsRotating\u0026#34;,DevComment=\u0026#34;\u0026#34;) Write macros for easy access to tags 1 2 3 // ABGameplayTag.h #define ABTAG_ACTOR_ROTATE FGameplayTag::RequestGameplayTag(FName(\u0026#34;Actor.Action.Rotate\u0026#34;)) #define ABTAG_ACTOR_ISROTATING FGameplayTag::RequestGameplayTag(FName(\u0026#34;Actor.State.IsRotating\u0026#34;)) Register tags in Gameplay Ability 1 2 3 4 5 6 UABGA_Rotate::UABGA_Rotate() { AbilityTags.AddTag(ABTAG_ACTOR_ROTATE); // Apply this tag when activated ActivationOwnedTags.AddTag(ABTAG_ACTOR_ISROTATING); } Register and activate ability using tags 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // ABGASFountain.h UPROPERTY(EditAnywhere, Category=GAS) TArray\u0026lt;TSubclassOf\u0026lt;UGameplayAbility\u0026gt;\u0026gt; Abilities; // Implementation void AABGASFountain::PostInitializeComponents() { Super::PostInitializeComponents(); AbilitySystemComponent-\u0026gt;InitAbilityActorInfo(this, this); for (auto Element : Abilities) { FGameplayAbilitySpec Spec(Element); AbilitySystemComponent-\u0026gt;GiveAbility(Spec); } } void AABGASFountain::TimerAction() { FGameplayTagContainer TargetTag(ABTAG_ACTOR_ROTATE); if(!AbilitySystemComponent-\u0026gt;HasMatchingGameplayTag(ABTAG_ACTOR_ISROTATING)) { AbilitySystemComponent-\u0026gt;TryActivateAbilitiesByTag(TargetTag); } else { AbilitySystemComponent-\u0026gt;CancelAbilities(\u0026amp;TargetTag); } } After creating a blueprint class that inherits from the AABGASFountain cpp class and adding the appropriate activities to Abilities in the Details panel, the process is complete.\nSummary Implemented the rotating fountain through three methods:\nExtending the functionality of the actor 2. GAS: Creating a new class (ability) to separate functionality from the actor GAS + Gameplay Tags: Removing dependencies between actor and ability using tags Benefits of using GAS and Gameplay Tags together\nMinimization of actor\u0026rsquo;s role Dependency removal. Easier maintenance and increased reusability Scalability + easy collaboration with other departments ","date":"2024-03-18T15:58:25+09:00","image":"https://sangho0n.github.io/en/p/starting-unreal-gas/img/unreal.svg","permalink":"https://sangho0n.github.io/en/p/starting-unreal-gas/","title":"Starting Unreal GAS"},{"content":"This post is to revive the memories that have faded while using other languages. In this post, we will take a closer look at the inheritance relationship and the virtual keyword in C++.\nInheritance Unlike other object-oriented languages like Java and C#, C++ allows specifying access specifiers during inheritance.\n1 2 // syntax class Derived : \u0026lt;access_specifier\u0026gt; Parent This indicates how the elements of the parent class will be inherited when inheriting a parent class. Think of it as replacing the elements specified loosely by the access_specifier with the specified type.\nLet\u0026rsquo;s examine three types of classes that inherit the following class:\n1 2 3 4 5 6 7 8 9 class Base { public: int pubInt = 1; private: int privInt = 2; protected: int protInt = 3; }; public Used to represent the is-a relationship. It follows the access specifier of the parent.\n1 2 3 4 5 6 7 8 9 10 class Pub : public Base // is-a { public: Pub() { pubInt = 1; // public //privInt = 2; // cannot access as it is private in the parent class protInt = 3; // protected } }; Therefore, externally, only the pubInt specified as public in the parent class can be accessed.\n1 2 3 4 Pub* pub = new Pub(); cout \u0026lt;\u0026lt; pub-\u0026gt;pubInt \u0026lt;\u0026lt; endl; //cout \u0026lt;\u0026lt; pub-\u0026gt;privInt \u0026lt;\u0026lt; endl; //error: ‘int Base::privInt’ is private within this context //cout \u0026lt;\u0026lt; pub-\u0026gt;protInt \u0026lt;\u0026lt; endl; //error: ‘int Base::protInt’ is protected within this context private Used to represent the is-implemented-in-terms-of relationship (default in C++). When inheriting, elements that can be accessed more loosely than private (elements defined as protected and public) in the parent class are inherited as private.\n1 2 3 4 5 6 7 8 9 10 class Priv : private Base // is-implemented-in-terms-of (cover this later) { public: Priv() { pubInt = 1; // public -\u0026gt; private //privInt = 2; // cannot access as it is private in the parent class protInt = 3; // protected -\u0026gt; private } }; Therefore, no element of the parent class can be accessed externally.\n1 2 3 4 Priv* priv = new Priv(); //cout \u0026lt;\u0026lt; priv-\u0026gt;pubInt \u0026lt;\u0026lt; endl; //error: ‘int Base::pubInt’ is inaccessible within this context //cout \u0026lt;\u0026lt; priv-\u0026gt;privInt \u0026lt;\u0026lt; endl; //error: ‘int Base::privInt’ is private within this context //cout \u0026lt;\u0026lt; priv-\u0026gt;protInt \u0026lt;\u0026lt; endl; //error: ‘int Base::protInt’ is protected within this context Furthermore, even if a new class is created that inherits from this class, no element of the grandparent class can be accessed.\n1 2 3 4 5 6 7 8 class GrandChild : Priv { public: GrandChild() { // Cannot access any element of Base } }; protected Used similarly to the private specifier to represent the is-implemented-in-terms-of relationship. It inherits public elements of the parent class as protected.\n1 2 3 4 5 6 7 8 9 10 class Prot : protected Base // is-implemented-in-terms-of { public: Prot() { pubInt = 1; // public -\u0026gt; protected //privInt = 2; // error: ‘int Base::privInt’ is private within this context protInt = 3;// protected } }; Therefore, no element of the Base class can be accessed from outside.\n1 2 3 4 Prot* prot = new Prot(); //cout \u0026lt;\u0026lt; prot-\u0026gt;pubInt \u0026lt;\u0026lt; endl; //error: ‘int Base::pubInt’ is inaccessible within this context //cout \u0026lt;\u0026lt; prot-\u0026gt;privInt \u0026lt;\u0026lt; endl; //error: ‘int Base::privInt’ is private within this context //cout \u0026lt;\u0026lt; prot-\u0026gt;protInt \u0026lt;\u0026lt; endl; // error: ‘int Base::protInt’ is protected within this context Similarly, when creating a class that inherits it, you can access the elements of the great-grandparent class.\n1 2 3 4 5 6 7 8 9 class GrandChild2 : Prot { public: GrandChild2() { pubInt = 1; // because it is specified protected protInt = 3; // because it is specified protected } }; However, since it was inherited as private by default, access to GrandChild2\u0026rsquo;s pubInt and protInt elements from outside is not allowed.\ncasting The support for casting in each case is as follows.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int main() { // upcasting check Base *ptr1, *ptr2, *ptr3; ptr1 = new Pub(); //ptr2 = new Priv(); // error: ‘Base’ is an inaccessible base of ‘Priv’ //ptr3 = new Prot(); // error: ‘Base’ is an inaccessible base of ‘Prot’ // downcasting check Base* base = new Base(); Pub* pub_down = static_cast\u0026lt;Pub*\u0026gt;(base); // Compile-time check. Does not worry about polymorphism // Pub* pub_down = dynamic_cast\u0026lt;Pub*\u0026gt;(base); // (source type is not polymorphic) error because there are no virtual functions // Priv* priv_down = static_cast\u0026lt;Priv*\u0026gt;(base); // error: ‘Base’ is an inaccessible base of ‘Priv’ // Prot* prot_down = static_cast\u0026lt;Prot*\u0026gt;(base); // error: ‘Base’ is an inaccessible base of ‘Prot’ delete ptr1, ptr2, ptr3, pub_down, base; return 0; } Someone familiar with other languages or who has never really thought about access modifiers in inheritance while developing might wonder what exactly is meant by is-implemented-in-terms-of for non-public inheritance.\nIs-Implemented-In-Terms-Of In general programming languages, the is-a relationship is represented using inheritance (public inheritance in the case of C++) and the has-a relationship is represented using composition (containment or aggregation) to model relationships between objects. In addition to the above two concepts, C++ uses the term is-implemented-in-terms-of to indicate relationships between objects.\nAs the name suggests, is-implemented-in-terms-of refers to a situation where one object behaves using another object. Therefore, is-implemented-in-terms-of can also be represented in C++ using composition. So, what is the difference between has-a and is-implemented-in-terms-of? The criterion separating the two relationships is the domain.\nThe has-a relationship is used to model an application domain that can be easily understood from everyday life in programming. For example, application domains like people, communication methods, transportation methods can be modeled as has-a relationships. On the other hand, is-implemented-in-terms-of signifies purely the domain of software implementation. Examples include buffers, mutexes, search trees, etc.\nIn C++, the has-a relationship can be implemented using composition, similar to other languages. On the other hand, the is-implemented-in-terms-of relationship can be implemented using composition like has-a or using non-public inheritance.\nKnowing that, when should we use non-public inheritance for implementation, and when should we use composition for it? Let\u0026rsquo;s look at classes implemented using both methods and see which approach is better.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 template \u0026lt;class T\u0026gt; class MyList { public: bool Insert( const T\u0026amp;, size_t index ); T Access( size_t index ) const; size_t Size() const; private: T* buf_; size_t bufsize_; }; template \u0026lt;class T\u0026gt; class MySet1 : private MyList\u0026lt;T\u0026gt; { public: bool Add( const T\u0026amp; ); // calls Insert() T Get( size_t index ) const; // calls Access() using MyList\u0026lt;T\u0026gt;::Size; //... }; template \u0026lt;class T\u0026gt; class MySet2 { public: bool Add( const T\u0026amp; ); // calls impl_.Insert() T Get( size_t index ) const; // calls impl_.Access() size_t Size() const; // calls impl_.Size(); //... private: MyList\u0026lt;T\u0026gt; impl_; }; Implementing with Inheritance vs. Implementing with Composition As can be seen from the example code above, everything that can be achieved with a single composition can also be implemented using inheritance. So, why does C++ differentiate between public, private, and protected inheritance?\nThe reason is that there are some cases in which something can be achieved with non-public inheritance but not with single composition. Below are 5 items, listed from the most common cases, where each condition applies:\nWhen there is a need to access protected members. Usually refers to cases where protected methods (or constructors) need to be called. When there is a need to override virtual functions. If the base class has a pure virtual function, composition cannot be used. When one implementation needs to be created (or destroyed) before another implementation is created. If multiple implementations are interdependent such that the lifetime of one implementation needs to cover the lifetimes of all others, something like a critical section or data transaction requiring a lock, then non-public inheritance is preferred. When there is a need to share virtual base classes and changes in the construction of virtual base classes are necessary. However, besides is-implemented-in-terms-of, which strays away, there is also another characteristic unique to non-public inheritance that cannot be implemented with composition alone.\nWhen \u0026lsquo;restricted polymorphism\u0026rsquo; is necessary; when limited Liskov substitution is required in some parts of the code. Public inheritance always allows Liskov substitution. On the other hand, non-public inheritance can represent a \u0026lsquo;restricted\u0026rsquo; IS-A relationship. Even though it may not feel very polymorphic from outside the class hierarchy (Derived is not a Base), there might be cases where polymorphism is needed inside member functions or friends. Let\u0026rsquo;s take another look at the MySet and MyList code. In this case,\nMyList does not have any protected members. MyList is not an abstract class. MySet does not inherit any other class besides MyList. MyList does not inherit a virtual base class required for or shared with MySet. MySet is not a MyList. MySet is-not-a MyList. Since none of the five situations above apply, it is advisable to implement it using composition rather than inheritance. Inheritance can expose unnecessary information to child classes and create more dependency than necessary.\nAlthough I feel that C++ has a lot of ways to implement object relationships compared to other languages, understanding these methods seems not only easy but also something that should not be overused as it can violate object-oriented principles.\nPolymorphism Polymorphism refers to the ability of the same operator or method to perform different functions. In C++, polymorphism can be implemented through operator/method overloading and method overriding. Method overriding, along with the virtual keyword, is what we will look into further this time.\nvirtual In C++, the virtual keyword is used when declaring virtual functions and when inheriting a virtual base class.\n1 2 3 4 5 // syntax virtual [type-specifiers] member_function_declarator class Class_Name : virtual [access-specifier] Base_Class_Name class Class_Name : [access-specifier] virtual Base_Class_Name Virtual Function Virtual functions are used to declare functions that child classes will override for polymorphism. Functions declared as virtual are registered in a vTable by the compiler for each class instance. The vPtr (virtual pointer) accesses these at runtime to determine which function to call.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 // C++ program to show the working of vtable and vptr #include \u0026lt;iostream\u0026gt; using namespace std; // base class class Base { public: virtual void function1() { cout \u0026lt;\u0026lt; \u0026#34;Base function1()\u0026#34; \u0026lt;\u0026lt; endl; } virtual void function2() { cout \u0026lt;\u0026lt; \u0026#34;Base function2()\u0026#34; \u0026lt;\u0026lt; endl; } virtual void function3() { cout \u0026lt;\u0026lt; \u0026#34;Base function3()\u0026#34; \u0026lt;\u0026lt; endl; } }; // class derived from Base class Derived1 : public Base { public: // overriding function1() void function1() { cout \u0026lt;\u0026lt; \u0026#34;Derived1 function1()\u0026#34; \u0026lt;\u0026lt; endl; } // not overriding function2() and function3() }; // class derived from Derived1 class Derived2 : public Derived1 { public: // again overriding function2() void function2() { cout \u0026lt;\u0026lt; \u0026#34;Derived2 function2()\u0026#34; \u0026lt;\u0026lt; endl; } // not overriding function1() and function3() }; // driver code int main() { // defining base class pointers Base* ptr1 = new Base(); Base* ptr2 = new Derived1(); Base* ptr3 = new Derived2(); // calling all functions ptr1-\u0026gt;function1(); ptr1-\u0026gt;function2(); ptr1-\u0026gt;function3(); ptr2-\u0026gt;function1(); ptr2-\u0026gt;function2(); ptr2-\u0026gt;function3(); ptr3-\u0026gt;function1(); ptr3-\u0026gt;function2(); ptr3-\u0026gt;function3(); // deleting objects delete ptr1; delete ptr2; delete ptr3; return 0; } Virtual Base Class C++ allows multiple inheritance. When an instance is created, the parent is created in memory first, followed by the child\u0026rsquo;s constructor being called. So, what happens if one class has different parents, but the same grandparent?\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;iostream\u0026gt; using namespace std; class A { public: void show() { cout \u0026lt;\u0026lt; \u0026#34;Hello from A \\n\u0026#34;; } }; class B : public A { }; class C : public A { }; class D : public B, public C { }; int main() { D object; object.show(); } In this case, A would try to occupy memory twice. Fortunately, the compiler detects this and throws an error. Actually, such an inheritance structure may cause the diamond problem, which is why it is not recommended.\nHowever, if you still want to call A\u0026rsquo;s show(), B and C should inherit A as a virtual base class.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class A { public: void show() { cout \u0026lt;\u0026lt; \u0026#34;Hello from A \\n\u0026#34;; } }; class B : virtual public A { }; class C : public virtual A { }; // Both syntaxes are valid References \u0026ldquo;Effective C++” Third Edition by Scott Meyers. Uses and Abuses of Inheritance What is the difference between public, private, and protected inheritance? virtual (C++) C++ Polymorphism vTable And vPtr in C++ Virtual base class in C++ ","date":"2024-03-08T11:12:45+09:00","image":"https://sangho0n.github.io/en/p/c-inheritance-and-the-virtual-keyword/img/cpp.svg","permalink":"https://sangho0n.github.io/en/p/c-inheritance-and-the-virtual-keyword/","title":"C++ Inheritance and the Virtual Keyword"},{"content":"Based on the official documentation, this article is written to explain the content. (Many interpretations) There may be differences from reality. Please point out if there are any.\nUnreal provides implementations for various smart pointers used in C++. The classes provided include Shared pointer, Weak pointer, Unique pointer, and uniquely, a type called Shared Reference has been added. Since UObject is managed by a separate memory tracking system, instances of classes that inherit from UObject cannot be wrapped with smart pointers. (Different approach to memory management, using the RAII pattern)\nTypes Type Name Usage TSharedPtr A shared pointer is a class that owns the object it wraps. It prevents the object from being destroyed by external forces while it is owned and ultimately manages the destruction of the object when the count of shared pointers (or references) owning the object reaches 0. A shared pointer can exist even when it doesn\u0026rsquo;t wrap an object. It can create a shared reference whenever the wrapped object is not null. TSharedRef Similar to a shared pointer, but the wrapped object cannot be null. Since null is not allowed, it can always be converted to a shared pointer, and the object it points to is always valid. Used when ownership needs to be clear or to guarantee that the object is not null. TWeakPtr Similar to a shared pointer but does not own the object, thus not affecting the object\u0026rsquo;s lifecycle. This feature can be useful for breaking reference cycles, but if you want to ensure safe access as objects can become null without warning, it is better to convert to a shared pointer before use. TUniquePtr A unique pointer exclusively owns the object. It can transfer ownership but cannot share it. Compiling errors occur when trying to copy a unique pointer. When it goes out of scope, it automatically releases the owned object from memory. 1) A situation where two or more objects refer to each other but neither can be deallocated due to a non-zero reference count, causing memory leaks.\nAdvantages Advantage Description Prevention of memory leaks Automatically destroys objects to prevent memory leaks. Weak references Solves circular reference problems and prevents dangling pointers. Thread safety optional Additional code can be written to ensure thread safety when needed. (Overhead exists) Runtime safety Shared references cannot be null and can be released at any time, providing runtime safety. Intent clarification Easily distinguish between owners and observers. Memory benefits All these functionalities are accomplished in just twice the size of a pointer variable in C++ (based on 64-bit systems; including 16 bytes for reference control). However, Unique pointer has the same size as a regular pointer. 1) Owner manages the object\u0026rsquo;s ownership and lifecycle. Through shared pointers and unique pointers, the object is owned and when no longer needed, it is deallocated from memory. The observer refers to an object but does not own it (Weak pointer). When the owner deletes the object, the observer should become null by itself.\nHelper Classes and Functions Helper Description Classes TSharedFromThis Inheriting from TSharedFromThis adds AsShared and SharedThis methods to the class. These methods assist in obtaining a TSharedRef for the object. Functions MakeShared and MakeShareable MakeShared function creates a TSharedPtr from a regular C++ pointer. It allocates a new object instance and reference controller in a single memory block. The object must have a public constructor. MakeShareable is also used to create a TSharedPtr from a C++ pointer. It works even if the object\u0026rsquo;s constructor is private. It can be used to obtain ownership of objects that were not created by the programmer, and allows the developer to provide custom logic when the destructor is called. These additional features allow for more flexible programming compared to MakeShared but come with overhead. StaticCastSharedRef and StaticCastSharedPtr Utility functions that support static casting (mostly downcasting). ConstCastSharedRef and ConstCastSharedPtr Return a mutable object from const for each reference and pointer type. Example of adding additional logic to the destructor using MakeShareable\n1 2 3 4 5 6 TSharedPtr\u0026lt;FOnlineSession\u0026gt; SharedPtr = MakeShareable(new FOnlineSession(), [](FOnlineSession* ObjToDelete)-\u0026gt; void { // Custom destructor implementation ObjToDelete-\u0026gt;PerformAdditionalCleanup(); delete ObjToDelete; }); Implementation Details Unreal\u0026rsquo;s smart pointer library is implemented to preserve both functionality and efficiency.\nSpeed Smart pointers are very useful in high-level systems like resource management and tool programming, but they are not suitable for low-level engine code such as rendering due to being slower than regular C++ pointers.\nThe Unreal smart pointer library has the following performance advantages:\nAll operations are performed in constant time. (Shipping build) Dereferencing time in most smart pointers is as fast as basic C++ pointers. Copying smart pointers does not require new memory allocation. Thread-safe smart pointers do not lock. However, there are also drawbacks:\nCreating and copying new smart pointers have overhead compared to basic C++ pointers. Managing reference counts introduces additional overhead in basic operations. Some smart pointers use more memory than basic C++ pointers. Reference controllers require two heap memory allocations. Using MakeShared instead of MakeShareable can avoid the second memory allocation. Intrusive Accessors Normally, an instance referenced by a smart pointer is unaware of the presence of the smart pointer that owns it (called non-intrusive). However, Unreal\u0026rsquo;s smart pointer library allows obtaining accessors for smart pointers referencing the instance through TSharedFromThis.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class FRegistryObject; class FMyBaseClass: public TSharedFromThis\u0026lt;FMyBaseClass\u0026gt; { virtual void RegisterAsBaseClass(FRegistryObject* RegistryObject) { // Access a shared reference to \u0026#39;this\u0026#39;. TSharedRef\u0026lt;FMyBaseClass\u0026gt; ThisAsSharedRef = AsShared(); RegistryObject-\u0026gt;Register(ThisAsSharedRef); } }; class FMyDerivedClass : public FMyBaseClass { virtual void Register(FRegistryObject* RegistryObject) override { TSharedRef\u0026lt;FMyDerivedClass\u0026gt; AsSharedRef = SharedThis(this); RegistryObject-\u0026gt;Register(ThisAsSharedRef); } }; class FRegistryObject { void Register(TSharedRef\u0026lt;FMyBaseClass\u0026gt;); }; By inheriting from TSharedFromThis, the class can obtain a shared pointer (TSharedRef) to itself using AsShared and SharedThis methods. Since the SharedRef method takes this as a parameter, it returns a different type for classes not directly inherited from TSharedFromThis. For methods that return a shared reference (or pointer) factory class or take a shared reference (or pointer) as a parameter, it is recommended to set the parameter type as the shared pointer of the base class that directly inherits TSharedFromThis.\nNote that AsShared and SharedThis return smart pointers to instantiated objects, so using them in constructors can lead to crashes or assertions.\nType Casting Just like regular C++ pointers, Unreal\u0026rsquo;s smart pointer library allows for type casting.\nUp Casting: Implicitly performed similar to C++ pointers (automatically converting a base class pointer to a derived class pointer). Const Casting: Use ConstCastSharedPtr/Ref methods to perform this. Static Casting: Use StaticCastSharedPtr/Ref methods to perform this (often used for downcasting). Dynamic Casting: Not supported due to the lack of runtime type information (RTTI). 1 2 3 4 5 6 TSharedPtr\u0026lt;FDragDropOperation\u0026gt; Operation = DragDropEvent.GetOperation(); // Validating that the FDragDropOperation is an FAssetDragDropOp... // Casting using StaticCastSharedPtr. TSharedPtr\u0026lt;FAssetDragDropOp\u0026gt; DragDropOp = StaticCastSharedPtr\u0026lt;FAssetDragDropOp\u0026gt;(Operation); Thread Safety By default, smart pointers are only safe in a single-threaded environment. If you want a thread-safe version, you can use the following classes:\nTSharedPtr\u0026lt;T, ESPMode::ThreadSafe\u0026gt; TSharedRef\u0026lt;T, ESPMode::ThreadSafe\u0026gt; TWeakPtr\u0026lt;T, ESPMode::ThreadSafe\u0026gt; TSharedFromThis\u0026lt;T, ESPMode::ThreadSafe\u0026gt; These classes perform atomic operations on reference counting, making them slightly slower than the default classes but behaving similarly to regular C++ pointers.\nReading and copying operations are always thread-safe. Write and reset operations must be synchronized for safety. Additional Notes Passing shared pointers/references as arguments to methods incurs overhead due to reference counting and dereferencing. If possible, pass them by const \u0026amp;. Incomplete classes can be forward-declared for shared pointers. As mentioned earlier, smart pointers and garbage collection (UObject Handling) are completely separate memory management systems. Forward declaration example\n1 2 3 4 5 6 7 8 // Forward declaration class IncompleteType; // Smart pointer for the forward-declared type TSharedPtr\u0026lt;IncompleteType\u0026gt; incompleteTypePtr; // When the definition of IncompleteType is completed later, it can be used to create a smart pointer of that type TSharedPtr\u0026lt;IncompleteType\u0026gt; incompleteTypePtr2 = MakeShared\u0026lt;IncompleteType\u0026gt;(); ","date":"2024-03-05T17:31:11+09:00","image":"https://sangho0n.github.io/en/p/unreal-smart-pointers/img/unreal.svg","permalink":"https://sangho0n.github.io/en/p/unreal-smart-pointers/","title":"Unreal Smart Pointers"},{"content":"When selecting a sorting algorithm, not only should you consider the time complexity in best, average, and worst conditions, but also factors such as memory usage and stability.\nThe speed of a comparison-based sorting algorithm in the worst case condition cannot be faster than O(nlog(n)).\nList of Sorting Algorithms in This Post Selection Sort Insertion Sort Bubble Sort Heap Sort Quick Sort Merge Sort Radix Sort Selection Sort One of the simplest algorithms. Suitable for environments where copying operations are slow due to being an in-place algorithm.\nIt scans the array once at each step, selects the minimum (or maximum) value among the unsorted elements and swaps it with the first element.\nAfter each step, it reduces the number of unsorted elements by 1 and repeats the same operation for the reduced array.\nIn-Place. Unstable.\nTime Complexity Case Complexity Best O(n2) Worst O(n2) Average O(n2) Insertion Sort Divides one array into a sorted and an unsorted array, increasing the size of the sorted array step by step and decreasing the size of the unsorted array.\nIt takes the front element of the unsorted array and compares it sequentially with the elements of the sorted array until it finds the right position to insert.\nIn-Place. Stable.\nTime Complexity Case Complexity Best (Already sorted) O(n) Worst O(n2) Average O(n2) Bubble Sort At each step, it linearly scans the array and performs comparisons and swaps with adjacent elements similar to bubbles rising in a cylinder.\nIn-Place. Stable.\nTime Complexity Case Complexity Best O(n2) Worst O(n2) Average O(n2) Heap Sort A method of sorting using a Max Heap or Min Heap. It is possible to use a separate heap or transform the given array into a heap (In-Place).\nThe operations of inserting/deleting elements in a heap are O(logn) (height of the heap, a complete binary tree), and performing these operations for the number of elements (twice; making the heap + removing one element from the heap) results in an overall time complexity of O(nlogn).\nIn-Place. Unstable.\nTime Complexity Case Complexity Best O(nlogn) Worst O(nlogn) Average O(nlogn) Quick Sort Divides the array into smaller arrays based on a pivot value, with smaller values on the left and larger values on the right.\nFor each divided array, Quick Sort is performed recursively until it cannot be divided further.\nIf the pivot is optimally selected at each moment, the given array is precisely halved each time. The worst case is when the pivot is always selected as the minimum value (or maximum value).\nIn-Place. Unstable.\nTime Complexity Case Complexity Best O(nlogn) Worst O(n2) Average O(nlogn) Merge Sort One of the divide-and-conquer algorithms. It divides the array in half and performs Merge Sort on each divided array. Then, it merges the sorted arrays together to obtain one large sorted array.\nUnlike other sorting algorithms, it has a space complexity of O(n) even in the best case.\nTo optimize the sorting of divided arrays, Merge Sort can be mixed with other sorting algorithms (such as Insertion Sort) based on a specific size (in this case, it may not be stable).\nNot In-Place. Stable.\nTime Complexity Case Complexity Best O(nlogn) Worst O(nlogn) Average O(nlogn) Radix Sort Unlike the previous algorithms, a sorting algorithm that performs without comparisons. It sorts based on digits, so the digits must be able to be sorted lexicographically.\nA type of bucket sort.\nNot In-Place. Stable\nTime Complexity Let n be the number of elements to be sorted, d be the maximum number of digits, and k be the number of buckets (for numbers, it is 10 as the digits are 0 to 9).\nBoth best, worst, and average cases have a complexity of O(d(n + k)).\n","date":"2024-02-26T11:49:35+09:00","image":"https://sangho0n.github.io/en/p/simple-summary-of-sorting-algorithms/img/algorithm_hu8666b0214ef6ef8b40207752073739fc_14421_120x120_fill_box_smart1_3.png","permalink":"https://sangho0n.github.io/en/p/simple-summary-of-sorting-algorithms/","title":"Simple Summary of Sorting Algorithms"},{"content":"\nStarting from Unreal Engine 5, the existing input mapping system has been deprecated. Let\u0026rsquo;s learn about the Enhanced Input that replaces it.\nEnhanced Input was introduced in UE5 to effectively support complex input processing and runtime control remapping. It is an upgraded version of UE4\u0026rsquo;s default input system, ensuring backward compatibility while enabling functionalities like radial dead zones, compound actions, combo attacks, etc. in an asset-based environment.\nCore Concepts The Enhanced Input system revolves around four core concepts:\nInput Action: Acts as a communication channel between Enhanced Input system and project code. An input action can report up to three independent floating-point values separate from the input that triggers it. Input Mapping Context: Responsible for mapping user inputs to input actions. These contexts can be dynamically added or removed for each user and can have priorities. By applying one or more input mapping contexts to a player and assigning priorities, conflicts between multiple actions triggered by the same input can be resolved. e.g., a door-opening button and a bag-opening button being the same button\nThe following two concepts provide elements to flexibly handle input processing:\nModifier: Used to refine input values, applying dead zones to prevent response to slight movements or smooth out input values. Developers can use predefined modifiers or define their own. Trigger: Determines whether to activate the input action based on data processed by modifiers or the resulting value of another input action. Input Actions Input Actions play a crucial role in connecting the Enhanced Input system with project code. To trigger an input action, you need to add the input action to an input mapping context and register the input mapping context with the Enhanced Input Local Player Subsystem of the local player.\nTo make a pawn react to a triggered input action, you need to control it using Blueprints or CPP code.\n1 2 3 4 5 6 7 8 9 10 11 12 void AMyCharacter::SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) { Super::SetupPlayerInputComponent(PlayerInputComponent); UEnhancedInputComponent* EnhancedInputComponent = CastChecked\u0026lt;UEnhancedInputComponent\u0026gt;(PlayerInputComponent); EnhancedInputComponent-\u0026gt;BindAction(MyAction, ETriggerEvent::Triggered, this, \u0026amp;AMyCharacter::MyAction); } void AMyCharacter::MyAction(const FInputActionValue\u0026amp; Value) { // do sth } Input Mapping Contexts In input mapping contexts, you can map inputs to input actions. Mapped contexts can be added to or removed from the Enhanced Input Local Player Subsystem of a local player at any time.\n1 2 3 4 5 6 7 8 9 10 11 12 // do sth ... APlayerController* PlayerController = CastChecked\u0026lt;APlayerController\u0026gt;(GetController()); if (UEnhancedInputLocalPlayerSubsystem* Subsystem = ULocalPlayer::GetSubsystem\u0026lt;UEnhancedInputLocalPlayerSubsystem\u0026gt;(PlayerController-\u0026gt;GetLocalPlayer())) { Subsystem-\u0026gt;ClearAllMappings(); UInputMappingContext* NewMappingContext = NewCharacterControl-\u0026gt;InputMappingContext; if (NewMappingContext) { Subsystem-\u0026gt;AddMappingContext(NewMappingContext, 0); } } // do sth ... Modifier Modifiers serve as preprocessors that adjust input values before sending them through triggers. Unreal Engine provides the following default modifiers.\nTo create a new modifier, you need to first create a class that inherits from the InputModifier class. Then, override the Modify Raw function. Directional Input One example of using modifiers effectively is utilizing a single input action for 2D directional input. When examining IA_Move and IMC_Default in a third-person template project, you can observe the following settings:\nKey Direction Scalar Value Modifier Desired Direction Vector w Up 1 Swizzle Input Axis Value (1, 0, 0) s Down 1 Swizzle Input Axis Value, Negate (-1, 0, 0) a Left 1 Negate (0, -1, 0) d Right 1 - (0, 1, 0) Looking at the declaration and partial implementation of the UInputModifierSwizzleAxis modifier, you can see:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 /** Swizzle axis components of an input value. * Useful to map a 1D input onto the Y axis of a 2D action. */ UCLASS(NotBlueprintable, MinimalAPI, meta = (DisplayName = \u0026#34;Swizzle Input Axis Values\u0026#34;)) class UInputModifierSwizzleAxis : public UInputModifier { GENERATED_BODY() public: // Default to XY swap, useful for binding 1D inputs to the Y axis. UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Settings) EInputAxisSwizzle Order = EInputAxisSwizzle::YXZ; protected: virtual FInputActionValue ModifyRaw_Implementation(const UEnhancedPlayerInput* PlayerInput, FInputActionValue CurrentValue, float DeltaTime) override; virtual FLinearColor GetVisualizationColor_Implementation(FInputActionValue SampleValue, FInputActionValue FinalValue) const override; }; FInputActionValue UInputModifierSwizzleAxis::ModifyRaw_Implementation(const UEnhancedPlayerInput* PlayerInput, FInputActionValue CurrentValue, float DeltaTime) { FVector Value = CurrentValue.Get\u0026lt;FVector\u0026gt;(); switch (Order) { case EInputAxisSwizzle::YXZ: Swap(Value.X, Value.Y); break; case EInputAxisSwizzle::ZYX: Swap(Value.X, Value.Z); break; case EInputAxisSwizzle::XZY: Swap(Value.Y, Value.Z); break; case EInputAxisSwizzle::YZX: Value = FVector(Value.Y, Value.Z, Value.X); break; case EInputAxisSwizzle::ZXY: Value = FVector(Value.Z, Value.X, Value.Y); break; } return FInputActionValue(CurrentValue.GetValueType(), Value); } With Order defaulting to YXZ, passing a scalar value of 1 through the modifier would result in a value of (1.0f, 0.0f, 0.0f). Setting up the modifier as described in the table allows you to transform scalar values into desired direction vectors.\nTrigger After modifiers process the input values, triggers determine whether to activate the input action based on the processed values or the resulting value of another input action. An exception is the Chorded Action trigger, which is triggered through another input action. The image below shows the default triggers.\nTriggers come in three types: Explicit, Implicit, and Blocker.\nExplicit: Input success upon trigger success Implicit: Input success on trigger success and all implicit trigger types\u0026rsquo; success Blocker: Input failure upon trigger success The table below displays trigger types and their corresponding classes.\nTrigger Class (CPP) Type UInputTrigger(default) ETriggerType::Explicit UInputTriggerCombo ETriggerType::Implicit UInputTriggerChordAction ETriggerType::Implicit UInputTriggerChordBlocker ETriggerType::Blocker Upon handling user inputs, triggers can return one of these three states:\nNone: Failed to trigger due to unmet conditions Ongoing: Partial fulfillment of conditions, trigger is processing but not yet successful Triggered: All input trigger conditions met and trigger successful By inheriting from the InputTrigger class or InputTriggerTimedBase class, you can create custom triggers. InputTriggerTimedBase checks if an input was maintained for a specific duration and returns an ongoing state during that duration. However, by default, it does not return triggered even when conditions are met. So, if inheriting and creating a new trigger using this class, you need to override the GetTriggerType and UpdateState methods to return the desired states.\n","date":"2024-02-14T17:44:19+09:00","image":"https://sangho0n.github.io/en/p/unreal-enhanced-input/img/unreal.svg","permalink":"https://sangho0n.github.io/en/p/unreal-enhanced-input/","title":"Unreal Enhanced Input"},{"content":"Summary of Lee Deok-woo\u0026rsquo;s lecture and documentation compiled by another developer.\nPlease refer to the links above for detailed and accurate information.\nSeries:\nUnreal GAS Overview \u0026lt;- Current Post Getting Started with Unreal GAS Gameplay Ability System Framework that provides actor abilities and interaction functions among actors through abilities Advantages Flexibility, scalability: Easily applicable to various and complex game productions Modular system: Minimizes dependencies for each function Network support Data-driven design Completeness: Games like Fortnite already utilize it Disadvantages Learning cost Overhead in small projects Suitable for creating large-scale RPGs and multiplayer games\nComponents Gameplay Abilities: Implementing character abilities based on cost and cooldown (optional) Attributes: Manipulation of actor\u0026rsquo;s characteristics Gameplay Effects: Changes in actor\u0026rsquo;s state based on ability activation Gameplay Tags: Tagging actors Gameplay Cues: Visual effects Replication for all of the above GAS in Multiplayer Games The GAS plugin supports client-side prediction, allowing ability activation and effects without server permission.\nAbility activation Animation montage playback Attribute changes Gameplay tag assignment Gameplay cue execution Movement control through RootMotionSource functions linked to CharacterMovementComponent Blueprint vs C++ GAS should be implemented using C++, but using Blueprints is possible for GameplayAbilities and GameplayEffects.\n","date":"2024-02-14T13:53:44+09:00","image":"https://sangho0n.github.io/en/p/unreal-gas-overview/img/unreal.svg","permalink":"https://sangho0n.github.io/en/p/unreal-gas-overview/","title":"Unreal GAS Overview"}]