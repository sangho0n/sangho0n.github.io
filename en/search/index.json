[{"content":"This post is a summary based on Lee Deukwoo\u0026rsquo;s lecture and documentation prepared by another developer.\nFor detailed and accurate information, please refer to the above links.\nSeries Basics of GAS Unreal GAS Overview Getting Started with Unreal GAS Basic Character Creation with GAS Handling Input in Unreal GAS Implementing Continuous Attacks in Unreal GAS \u0026lt;- Current Post Implementing Attack Judgment System in Unreal GAS Attributes and Gameplay Effects Unreal GAS Character Attributes Unreal GAS Gameplay Effects Interfacing Attributes and UI in Unreal GAS Utilizing GAS Implementing Item Crate in Unreal GAS Implementing Area of Effect Skill in Unreal GAS In this post, we will explore how animation sections registered in animation montages can be played in GAS and create a custom Task while learning how to use Ability Tasks in blueprints.\nImplementing Continuous Attack In the previous post, we represented the attack motion by playing the first section of the animation montage using UAbilityTask_PlayMontageAndWait. The Gameplay Ability class in GAS already defines a method that allows changing the animation to be played based on the section\u0026rsquo;s name.\n1 2 3 4 5 6 7 8 9 10 void UGameplayAbility::MontageJumpToSection(FName SectionName) { check(CurrentActorInfo); UAbilitySystemComponent* const AbilitySystemComponent = GetAbilitySystemComponentFromActorInfo_Checked(); if (AbilitySystemComponent-\u0026gt;IsAnimatingAbility(this)) { AbilitySystemComponent-\u0026gt;CurrentMontageJumpToSection(SectionName); } } Let\u0026rsquo;s implement continuous attacks using this method.\nNaive Approach The most basic mechanism to implement continuous attacks is as follows:\nRegister the animation montage in the animation instance Set an AnimNotify (NextComboCheck) to verify at the end of each animation montage section if it can transition to the next section When an attack request is received before the attack ends, set a flag to proceed to the next section Check the flag in AnimNotify and transition to the next section using the Montage_JumpToSection method 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 // Invoked upon attack input void AMyCharacter::AttackNonEquip_Multicast_Implementation() { auto animInstance = Cast\u0026lt;UMSBAnimInstance\u0026gt;(GetMesh()-\u0026gt;GetAnimInstance()); if(CharacterState-\u0026gt;IsAttacking()) { animInstance-\u0026gt;SetNextComboInputOn(true); } else { CharacterState-\u0026gt;SetAttacking(true); animInstance-\u0026gt;PlayComboAnim(); } } // Play continuous attack animation montage void UMyAnimInstance::PlayComboAnim() { CurrentCombo = 1; NextComboInputOn = false; Montage_Play(ComboMontage); } void UMyAnimInstance::AnimNotify_NextComboCheck() { if(NextComboInputOn) { JumpToNextSection(); NextComboInputOn = false; } } FName UMyAnimInstance::GetNextComboSectionName() { CurrentCombo = FMath::Clamp(CurrentCombo+1, 1, MaxComboCount); auto NextSection = FName(*FString::Printf(TEXT(\u0026#34;Combo%d\u0026#34;), CurrentCombo)); return NextSection; } void UMSBAnimInstance::JumpToNextSection() { auto text = GetNextComboSectionName(); Montage_JumpToSection(text, ComboMontage); } Using GAS We will now implement the equivalent code keeping in mind the following:\nUse of GAS Separate and manage Montage Section data as assets (enables rapid development without needing to recompile code even if the total number of attacks, playback speed, etc., change) Use of Timer instead of AnimNotify Primary Data Asset class used:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 void UABGA_Attack::ActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, const FGameplayEventData* TriggerEventData) { Super::ActivateAbility(Handle, ActorInfo, ActivationInfo, TriggerEventData); auto Character = CastChecked\u0026lt;AABCharacterBase\u0026gt;(ActorInfo-\u0026gt;AvatarActor.Get()); Character-\u0026gt;GetCharacterMovement()-\u0026gt;SetMovementMode(EMovementMode::MOVE_None); CurrentComboData = Character-\u0026gt;GetComboActionData(); // Retrieved ABA_ComboAttack defined earlier UAbilityTask_PlayMontageAndWait* PlayerAttackTask = UAbilityTask_PlayMontageAndWait::CreatePlayMontageAndWaitProxy( this, FName(\u0026#34;PlayAttack\u0026#34;), Character-\u0026gt;GetComboActionMontage(), 1.0f, GetNextSection() ); PlayerAttackTask-\u0026gt;OnCompleted.AddDynamic(this, \u0026amp;ThisClass::OnActionComplete); PlayerAttackTask-\u0026gt;OnCompleted.AddDynamic(this, \u0026amp;ThisClass::OnActionInterrupted); PlayerAttackTask-\u0026gt;ReadyForActivation(); StartComboTimer(); } void UABGA_Attack::InputPressed(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo) { //Super::InputPressed(Handle, ActorInfo, ActivationInfo); if(!ComboTimerHandle.IsValid()) { HasNextComboInputOn = false; } else { HasNextComboInputOn = true; } } FName UABGA_Attack::GetNextSection() { CurrentCombo = FMath::Clamp(CurrentCombo + 1, 1, CurrentComboData-\u0026gt;MaxComboCount); auto NextSection = FString::Printf(TEXT(\u0026#34;%s%d\u0026#34;), *CurrentComboData-\u0026gt;MontageSectionNamePrefix, CurrentCombo); return FName(NextSection); } void UABGA_Attack::StartComboTimer() { int32 ComboIndex = CurrentCombo - 1; ensure(CurrentComboData-\u0026gt;EffectiveFrameCount.IsValidIndex(ComboIndex)); float ComboEffectiveTime = CurrentComboData-\u0026gt;EffectiveFrameCount[ComboIndex] / CurrentComboData-\u0026gt;FrameRate; if(ComboEffectiveTime \u0026gt; 0.0f) { GetWorld()-\u0026gt;GetTimerManager() .SetTimer(ComboTimerHandle, this, \u0026amp;ThisClass::CheckComboInput, ComboEffectiveTime, false); } } void UABGA_Attack::CheckComboInput() { ComboTimerHandle.Invalidate(); if(HasNextComboInputOn) { MontageJumpToSection(GetNextSection()); // pre-defined from super class StartComboTimer(); HasNextComboInputOn = false; } } Custom Ability Task In the previous post, we implemented jumping using the provided Jump ability, but handling the state transitions as needed was not straightforward, and directly jumping the character from the ability made it challenging to adapt to additional requirements. Let\u0026rsquo;s create a new Jump ability and task to learn how to restrict the activation of different abilities based on the character\u0026rsquo;s state.\nImplementation (C++) The custom Task implementation follows the Custom Ability Task Creation Pattern we mentioned earlier.\nDeclare a delegate that broadcasts when the Task has completed Declare a callback function to be bound to this delegate in the Ability Use the ReadyForActivation method to make the Task executable End the Ability in the method called by the delegate In this case, the Jump Task ends when the character lands, meaning when the character\u0026rsquo;s feet touch the ground.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 // Task Implementation void UABAT_JumpAndWaitForLanding::Activate() { Super::Activate(); ACharacter* Character = CastChecked\u0026lt;ACharacter\u0026gt;(GetAvatarActor()); Character-\u0026gt;LandedDelegate.AddDynamic(this, \u0026amp;ThisClass::OnLanded); Character-\u0026gt;Jump(); SetWaitingOnAvatar(); } void UABAT_JumpAndWaitForLanding::OnDestroy(bool bInOwnerFinished) { ACharacter* Character = CastChecked\u0026lt;ACharacter\u0026gt;(GetAvatarActor()); Character-\u0026gt;LandedDelegate.RemoveDynamic(this, \u0026amp;ThisClass::OnLanded); Super::OnDestroy(bInOwnerFinished); } void UABAT_JumpAndWaitForLanding::OnLanded(const FHitResult\u0026amp; Hit) { if(ShouldBroadcastAbilityTaskDelegates()) { OnComplete.Broadcast(); } } // Ability Implementation UABGA_Jump::UABGA_Jump() { InstancingPolicy = EGameplayAbilityInstancingPolicy::InstancedPerActor; } void UABGA_Jump::ActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, const FGameplayEventData* TriggerEventData) { Super::ActivateAbility(Handle, ActorInfo, ActivationInfo, TriggerEventData); // Implement jump using custom ability task auto JumpAndWaitForLandingTask = UAbilityTask::NewAbilityTask\u0026lt;UABAT_JumpAndWaitForLanding\u0026gt;(this); JumpAndWaitForLandingTask-\u0026gt;OnComplete.AddDynamic(this, \u0026amp;ThisClass::OnLanded); // JumpAndWaitForLandingTask-\u0026gt;ReadyForActivation(); } void UABGA_Jump::InputReleased(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo) { auto Character = CastChecked\u0026lt;ACharacter\u0026gt;(ActorInfo-\u0026gt;AvatarActor.Get()); Character-\u0026gt;StopJumping(); Super::InputReleased(Handle, ActorInfo, ActivationInfo); } bool UABGA_Jump::CanActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayTagContainer* SourceTags, const FGameplayTagContainer* TargetTags, FGameplayTagContainer* OptionalRelevantTags) const { bool bResult = Super::CanActivateAbility(Handle, ActorInfo, SourceTags, TargetTags, OptionalRelevantTags); if(!bResult) return false; const auto Character = CastChecked\u0026lt;ACharacter\u0026gt;(ActorInfo-\u0026gt;AvatarActor.Get()); return (Character \u0026amp;\u0026amp; Character-\u0026gt;CanJump()); } void UABGA_Jump::OnLanded() { EndAbility(CurrentSpecHandle, CurrentActorInfo, CurrentActivationInfo, true, false); } To make tags on whether to block activation for jumping or attacking, these were specified in blueprints. For jumping, it isn\u0026rsquo;t allowed to attack, and for attacking, it isn\u0026rsquo;t allowed to jump. This was achieved by setting the Activation Blocked Tags.\nUsing custom task in Blueprints The method UAbilityTask::NewAbilityTask cannot be called from blueprints. While modifying engine code is an option, here, we will create a separate static method for task creation and declare the OnComplete delegate as BlueprintAssignable to let blueprints know when the task has completed.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 DECLARE_DYNAMIC_MULTICAST_DELEGATE(FJumpAndWaitForLandingDelegate); /** * */ UCLASS() class ARENABATTLEGAS_API UABAT_JumpAndWaitForLanding : public UAbilityTask { GENERATED_BODY() public: UABAT_JumpAndWaitForLanding(); UFUNCTION(BlueprintCallable, Category=\u0026#34;Abiltiy|Task\u0026#34;, meta=( DisplayName = \u0026#34;JumpAndWaitForLanding\u0026#34;, HidePin = \u0026#34;OwningAbility\u0026#34;, DefaultToSelf = \u0026#34;OwningAbility\u0026#34;, BlueprintInternalUseOnly=true)) static UABAT_JumpAndWaitForLanding* CreateTask(UGameplayAbility* OwningAbility); virtual void Activate() override; virtual void OnDestroy(bool bInOwnerFinished) override; UPROPERTY(BlueprintAssignable) FJumpAndWaitForLandingDelegate OnComplete; protected: UFUNCTION() void OnLanded(const FHitResult\u0026amp; Hit); }; UABAT_JumpAndWaitForLanding* UABAT_JumpAndWaitForLanding::CreateTask(UGameplayAbility* OwningAbility) { UABAT_JumpAndWaitForLanding* NewTask = NewAbilityTask\u0026lt;UABAT_JumpAndWaitForLanding\u0026gt;(OwningAbility); return NewTask; } After modifying the task code as above, the part in UABGA_Jump::ActivateAbility where the task was created and ReadyForActivation was called should be commented out. Then, in the blueprint of the Jump ability, bind the delegates.\n","date":"2024-04-01T13:53:44+09:00","image":"https://sangho0n.github.io/en/p/unreal-gas-continuous-attack-implementation/img/unreal.svg","permalink":"https://sangho0n.github.io/en/p/unreal-gas-continuous-attack-implementation/","title":"Unreal GAS Continuous Attack Implementation"},{"content":"[This post is a summary based on lectures by Lee Deok-Woo and documentation prepared by another developer. For detailed and accurate information, please refer to the mentioned links.\nSeries GAS Basics Unreal GAS Overview Unreal GAS Start \u0026lt;- Current Post GAS Character Creation Basics Unreal GAS Input Handling Unreal GAS Implementing Continuous Attacks Unreal Gas Implementing Attack Judgment System Attributes and Gameplay Effects Unreal GAS Character Attributes Unreal GAS Gameplay Effects Unreal GAS Attribute and UI Integration Utilization of GAS Unreal GAS Implementing Item Boxes Unreal GAS Implementing Area of Effect Skills In this post, we will explore three different ways to implement actor movement and understand the usage of the GAS framework while looking at the differences between each method.\nActor Function Extension Using Game Ability System Using Game Ability System + Gameplay Tags For the actor, the fountain, the movement is based on rotating in place for 3 seconds.\nActor Function Extension Implemented using URotatingMovementComponent directly without the GAS framework.\nUsing Game Ability System To implement movement using the GAS framework, you need to understand two concepts:\nAbility System Component Game Ability Ability System Component Manages the Gameplay Ability System Only one can be attached per actor Actors can trigger Gameplay Abilities through this component Allows interaction among actors with this component by the Game Ability System Game Ability An action that can be registered and triggered within the Ability System Component Activation Process: Register in Ability System Component: AbilitySystemComponent-\u0026gt;GiveAbility() Trigger the action: AbilitySystemComponent-\u0026gt;TryActivateAbility() Implement requirements using SpecHandle, ActorInfo, ActivationInfo within the activated ability Key Methods: CanActivateAbility ActivateAbility CancelAbility EndAbility Implementing the same movement using the above concepts with the GAS framework:\n\u0026hellip;\nUsing Game Ability System + Gameplay Tags When using only the Game Ability System without Gameplay Tags, the advantages of the GAS framework may not be fully utilized. Let\u0026rsquo;s understand what Gameplay Tags are:\n\u0026hellip;\nImplement the same requirements using Gameplay Tags:\n\u0026hellip;\nConclusion Implemented the rotating fountain using three methods:\nActor function extension GAS: Separating functionality from the actor with a new class (ability) GAS + Gameplay Tags: Removing dependencies using tags ","date":"2024-03-18T15:58:25+09:00","image":"https://sangho0n.github.io/en/p/unreal-gas-start/img/unreal.svg","permalink":"https://sangho0n.github.io/en/p/unreal-gas-start/","title":"Unreal GAS Start"},{"content":"This post aims to delve into the details of inheritance relationships and the virtual keyword in C++ in order to revive memories blurred by using other languages.\nInheritance Unlike other object-oriented languages such as Java and C#, C++ allows you to specify access specifiers during inheritance.\n1 2 // syntax class Derived : \u0026lt;access_specifier\u0026gt; Parent This indicates how the elements of the parent class are to be acquired when inheriting from the parent class. Think of replacing the elements loosely specified in the access_specifier with those specified by the type for inheritance.\nLet\u0026rsquo;s look at three types of classes that inherit the following class and examine the characteristics of each.\n1 2 3 4 5 6 7 8 9 class Base { public: int pubInt = 1; private: int privInt = 2; protected: int protInt = 3; }; public Used to represent the is-a relationship. It follows the access specifier of the parent.\n1 2 3 4 5 6 7 8 9 10 class Pub : public Base // is-a { public: Pub() { pubInt = 1; // public //privInt = 2; // Cannot access parent class\u0026#39;s private protInt = 3; // protected } }; Therefore, external access is limited to the pubInt of the parent class specified as public.\n1 2 3 4 Pub* pub = new Pub(); cout \u0026lt;\u0026lt; pub-\u0026gt;pubInt \u0026lt;\u0026lt; endl; //cout \u0026lt;\u0026lt; pub-\u0026gt;privInt \u0026lt;\u0026lt; endl; //error: ‘int Base::privInt’ is private within this context //cout \u0026lt;\u0026lt; pub-\u0026gt;protInt \u0026lt;\u0026lt; endl; //error: ‘int Base::protInt’ is protected within this context private Used when representing the is-implemented-in-terms-of relationship (default in cpp). Private inheritance inherits the elements of the parent class that can be accessed less strictly than private (i.e., protected and public elements) as private.\n1 2 3 4 5 6 7 8 9 10 class Priv : private Base // is-implemented-in-terms-of { public: Priv() { pubInt = 1; // public -\u0026gt; private //privInt = 2; // Cannot access parent class\u0026#39;s private protInt = 3; // protected -\u0026gt; private } }; Therefore, external access is prevented to any elements of the parent class.\n1 2 3 4 Priv* priv = new Priv(); //cout \u0026lt;\u0026lt; priv-\u0026gt;pubInt \u0026lt;\u0026lt; endl; //error: ‘int Base::pubInt’ is inaccessible within this context //cout \u0026lt;\u0026lt; priv-\u0026gt;privInt \u0026lt;\u0026lt; endl; //error: ‘int Base::privInt’ is private within this context //cout \u0026lt;\u0026lt; priv-\u0026gt;protInt \u0026lt;\u0026lt; endl; //error: ‘int Base::protInt’ is protected within this context Furthermore, even if a new class inherits from this class, access to any elements of the great-grandparent class is still unavailable.\n1 2 3 4 5 6 7 8 class GrandChild : Priv { public: GrandChild() { // Unable to access any elements of Base } }; protected Same as the private specifier, it is used when representing the is-implemented-in-terms-of relationship. It inherits the parent class\u0026rsquo;s public elements as protected.\n1 2 3 4 5 6 7 8 9 10 class Prot : protected Base // is-implemented-in-terms-of { public: Prot() { pubInt = 1; // public -\u0026gt; protected //privInt = 2; // error: ‘int Base::privInt’ is private within this context protInt = 3; // protected } }; Therefore, external access is denied to any elements of the Base class.\n1 2 3 4 Prot* prot = new Prot(); //cout \u0026lt;\u0026lt; prot-\u0026gt;pubInt \u0026lt;\u0026lt; endl; //error: ‘int Base::pubInt’ is inaccessible within this context //cout \u0026lt;\u0026lt; prot-\u0026gt;privInt \u0026lt;\u0026lt; endl; //error: ‘int Base::privInt’ is private within this context //cout \u0026lt;\u0026lt; prot-\u0026gt;protInt \u0026lt;\u0026lt; endl; // error: ‘int Base::protInt’ is protected within this context Moreover, unlike private, when a class inherits from this, it\u0026rsquo;s possible to access the elements of the great-grandparent class.\n1 2 3 4 5 6 7 8 9 class GrandChild2 : Prot { public: GrandChild2() { pubInt = 1; // because it is specified protected protInt = 3; // because it is specified protected } }; casting The supported cast for each case is as follows.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int main() { // upcasting check Base *ptr1, *ptr2, *ptr3; ptr1 = new Pub(); //ptr2 = new Priv(); // error: ‘Base’ is an inaccessible base of ‘Priv’ //ptr3 = new Prot(); // error: ‘Base’ is an inaccessible base of ‘Prot’ // downcasting check Base* base = new Base(); Pub* pub_down = static_cast\u0026lt;Pub*\u0026gt;(base); // checked at compile-time. Doesn\u0026#39;t consider polymorphism // Pub* pub_down = dynamic_cast\u0026lt;Pub*\u0026gt;(base); // error because source type is not polymorphic // Priv* priv_down = static_cast\u0026lt;Priv*\u0026gt;(base); // error: ‘Base’ is an inaccessible base of ‘Priv’ // Prot* prot_down = static_cast\u0026lt;Prot*\u0026gt;(base); // error: ‘Base’ is an inaccessible base of ‘Prot’ delete ptr1, ptr2, ptr3, pub_down, base; return 0; } is-implemented-in-terms-of In general programming languages, the is-a relationship is represented using inheritance (in the case of C++, public inheritance) and the has-a relationship is modeled using composition (containment, aggregation). C++ introduces the is-implemented-in-terms-of term to indicate relationships between objects where one object uses another to function. Thus, in C++, is-implemented-in-terms-of can also be represented using composition. Then, what is the difference between has-a and is-implemented-in-terms-of? The distinction between the two relationships lies in their domain.\nThe has-a relationship is used to model application domains that we can easily recognize in real life into programming. For example, application domains like people, means of communication, and modes of transport are modeled through the has-a relationship. On the other hand, is-implemented-in-terms-of is used solely to indicate the realm of software implementation. Examples include buffers, mutexes, and search trees.\nC++ provides the flexibility for implementing has-a relationships using composition or non-public inheritance for is-implemented-in-terms-of relationships.\nSo, when should we implement a feature using non-public inheritance, and when should we use composition? It\u0026rsquo;s worth examining which approach is suitable by looking at examples of classes created using both methods.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 template \u0026lt;class T\u0026gt; class MyList { public: bool Insert( const T\u0026amp;, size_t index ); T Access( size_t index ) const; size_t Size() const; private: T* buf_; size_t bufsize_; }; template \u0026lt;class T\u0026gt; class MySet1 : private MyList\u0026lt;T\u0026gt; { public: bool Add( const T\u0026amp; ); // calls Insert() T Get( size_t index ) const; // calls Access() using MyList\u0026lt;T\u0026gt;::Size; //... }; template \u0026lt;class T\u0026gt; class MySet2 { public: bool Add( const T\u0026amp; ); // calls impl_.Insert() T Get( size_t index ) const; // calls impl_.Access() size_t Size() const; // calls impl_.Size(); //... private: MyList\u0026lt;T\u0026gt; impl_; }; Implementation with Inheritance vs. Composition As you can see from the above example, whatever can be done with a single composition can also be implemented with inheritance. So, why does C++ distinguish between is-implemented-in-terms-of and has-a?\nThe reason lies in that some features can be implemented with non-public inheritance but not with a single composition. Below are five items indicating when to use each method (roughly listed starting from the most common case).\nWhen access to protected members is needed. This usually refers to the need to call protected methods (or constructors). When there is a need to override virtual functions. If the base class has a pure virtual function, composition cannot be used. When an implementation needs to be constructed (or destroyed) before (or after) another implementation. If multiple implementations depend on one another such that a specific implementation\u0026rsquo;s lifecycle must cover all others, critical sections like locks, data transactions, etc., it becomes crucial. When sharing a virtual base class or modification is needed when creating a virtual base class. Lastly, despite being distant from is-implemented-in-terms-of, non-public inheritance possesses another characteristic that composition alone cannot achieve.\nWhen \u0026lsquo;restricted polymorphism\u0026rsquo; is required. Cases where the Liskov substitution principle needs to be applied only to certain pieces of code. Public inheritance guarantees Liskov substitution always, while non-public inheritance can denote a more limited IS-A relationship. Although from the outside, non-public inheritance may not seem polymorphic at all (D is not a B), situations might arise in member functions or friend classes where polymorphism is needed. Let\u0026rsquo;s revisit the MySet and MyList code. In this case:\nMyList has no protected members. MyList is not an abstract class. MySet has no other classes inherited except MyList. MyList does not inherit any virtual base class. MySet is not MyList; MySet is-not-a MyList As none of the above five situations apply, it\u0026rsquo;s best to implement it using composition rather than inheritance. Using inheritance can expose unnecessary information to subclasses and create unnecessary dependencies.\nWith a thorough review, it seems that C++ offers a variety of ways in implementing object relationships compared to other languages. However, it is not easy to understand, and it seems that there are many aspects to consider to avoid violating the principles of object-oriented programming.\nNote: The source of this translation is present in the original document.\n","date":"2024-03-08T11:12:45+09:00","image":"https://sangho0n.github.io/en/p/c-inheritance-and-the-virtual-keyword/img/cpp.svg","permalink":"https://sangho0n.github.io/en/p/c-inheritance-and-the-virtual-keyword/","title":"C++ Inheritance and the virtual Keyword"},{"content":"Based on the official documentation, this document provides insights into Unreal\u0026rsquo;s implementation of various smart pointers used in C++. The provided classes include Shared Pointers, Weak Pointers, Unique Pointers, and an additional type known as Shared Reference. Due to separate memory management for UObjects, instances of classes inherited from UObject cannot be wrapped with smart pointers (memory is reclaimed differently, following the RAII pattern).\nTypes of Pointers Type Usage TSharedPtr A shared pointer owns the encapsulated object. It prevents the object from being destroyed while it is owned externally, and ultimately governs the destruction of the object when the count of shared pointers (or references) owning it becomes 0. A shared pointer can exist even when it doesn\u0026rsquo;t encapsulate an object. You can create a shared reference anytime the encapsulated object is not null. TSharedRef Similar to a shared pointer, but the encapsulated object cannot be null. Since null is impossible, it can be converted to a shared pointer anytime, ensuring that the object being pointed to is always valid. It is used when explicit ownership of an object is desired or when ensuring that an object is not null. TWeakPtr Similar to a shared pointer, but it does not own the object, allowing it to not affect the reference\u0026rsquo;s lifecycle. It can be useful for breaking reference cycles, but accessing an object simultaneously can become null without warning. If safe access is desired, it\u0026rsquo;s recommended to convert it to a shared pointer first. TUniquePtr A unique pointer exclusively owns the object. Although ownership can be transferred, it cannot be shared. Trying to copy a unique pointer results in a compile error in all cases. When the scope is exited, the owned object is automatically released from memory. 1) Refers to a situation where two or more objects reference each other, preventing each other from being released because the reference count never reaches 0, potentially leading to memory leaks.\nBenefits Benefit Description Prevention of Memory Leaks Automatically deallocates objects, preventing memory leaks. Weak References Solves circular reference issues and prevents dangling pointer problems. Optional Thread Safety Additional code can be added for thread safety when needed (comes with overhead). Runtime Safety Shared references cannot be null and can release references at any time, ensuring runtime safety. Intentional Conveyance Easily distinguishes between owners and observers. Memory Benefits Performs all functions with just twice the size of a pointer variable in C++ (based on 64-bit systems; including 16 bytes for reference control). However, a unique pointer has the same size as a C++ pointer. 1) Owners own objects and manage their lifecycles. They can own and release objects using shared pointers and unique pointers when they are no longer needed. Observers reference objects but do not own them (weak pointers). When the owner deletes the object, the observer should become null.\nHelper Classes and Functions Helper Description Classes TSharedFromThis Inheriting from TSharedFromThis adds AsShared and SharedThis methods to the class. These methods help obtain a TSharedRef for the object. Functions MakeShared and MakeShareable MakeShared creates a TSharedPtr from a regular C++ pointer. It allocates a new object instance and a reference controller in a single memory block. The object must have a public constructor. MakeShareable is also used to create a TSharedPtr from a C++ pointer. It works even if the object\u0026rsquo;s constructor is private. It allows ownership of objects not created by oneself and can provide custom logic upon destruction. This flexibility can lead to additional programming practices compared to MakeShared but comes with additional overhead. StaticCastSharedRef and StaticCastSharedPtr Utility functions supporting static casting (usually downcasting). ConstCastSharedRef and ConstCastSharedPtr Return a const to mutable object for each reference and pointer type variable. Example of using MakeShareable to add additional logic to the destructor:\n1 2 3 4 5 6 TSharedPtr\u0026lt;FOnlineSession\u0026gt; SharedPtr = MakeShareable(new FOnlineSession(), [](FOnlineSession* ObjToDelete)-\u0026gt; void { // Custom destructor implementation ObjToDelete-\u0026gt;PerformAdditionalCleanup(); delete ObjToDelete; }); Detailed Implementation Unreal\u0026rsquo;s smart pointers library is implemented with both functionality and efficiency in mind.\nSpeed While smart pointers are beneficial in high-level systems like resource management and tool programming, they are not suitable for low-level engine code such as rendering due to performance overhead compared to raw C++ pointers.\nUnreal\u0026rsquo;s smart pointers library provides the following performance advantages:\nAll operations are performed in constant time. (In shipping builds) Dereferencing in most smart pointers is as fast as raw C++ pointers. Copying a smart pointer does not require new memory allocation. Thread-safe smart pointers do not require locking. However, there are some drawbacks as well:\nCreating and copying new smart pointers have overhead compared to raw C++ pointers. Managing reference counts adds computational overhead to basic operations. Some smart pointers require more memory than raw C++ pointers. Reference controllers require two heap memory allocations. Using MakeShared can eliminate the second memory allocation. Intrusive Accessors By inheriting TSharedFromThis, a class can obtain accessors for shared pointers that reference it. This allows objects to know which shared pointers are referencing them.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class FRegistryObject; class FMyBaseClass: public TSharedFromThis\u0026lt;FMyBaseClass\u0026gt; { virtual void RegisterAsBaseClass(FRegistryObject* RegistryObject) { // Access a shared reference to \u0026#39;this\u0026#39;. TSharedRef\u0026lt;FMyBaseClass\u0026gt; ThisAsSharedRef = AsShared(); RegistryObject-\u0026gt;Register(ThisAsSharedRef); } }; class FMyDerivedClass : public FMyBaseClass { virtual void Register(FRegistryObject* RegistryObject) override { TSharedRef\u0026lt;FMyDerivedClass\u0026gt; AsSharedRef = SharedThis(this); RegistryObject-\u0026gt;Register(ThisAsSharedRef); } }; class FRegistryObject { void Register(TSharedRef\u0026lt;FMyBaseClass\u0026gt;); }; As mentioned, by inheriting TSharedFromThis, a class can use AsShared and SharedThis methods to obtain a shared reference of its instance. Note that the SharedRef method returns a shared reference to the originally specified type in TSharedFromThis, while SharedThis returns a shared reference with the type of \u0026rsquo;this\u0026rsquo;. It is recommended to use the shared pointer of the base class directly when passing shared pointers in method parameters.\nBe cautious when using AsShared and SharedThis in constructors, as it may lead to crashes or asserts.\nType Casting Unreal\u0026rsquo;s smart pointers library allows casting similar to raw C++ pointers.\nUp Casting: Implicitly performed, allowing a base class pointer to be automatically converted to a derived class pointer. Const Casting: Use ConstCastSharedPtr/Ref methods for const casting. Static Casting: Use StaticCastSharedPtr/Ref methods for static casting (usually downcasting). Dynamic Casting: Dynamic casting is not supported due to the absence of runtime type information (RTTI). 1 2 3 4 5 6 TSharedPtr\u0026lt;FDragDropOperation\u0026gt; Operation = DragDropEvent.GetOperation(); // Validating that the FDragDropOperation is an FAssetDragDropOp through other means... // Casting with StaticCastSharedPtr TSharedPtr\u0026lt;FAssetDragDropOp\u0026gt; DragDropOp = StaticCastSharedPtr\u0026lt;FAssetDragDropOp\u0026gt;(Operation); Thread Safety By default, smart pointers are only safe in single-threaded environments. If you want a thread-safe version, you can use classes like:\nTSharedPtr\u0026lt;T, ESPMode::ThreadSafe\u0026gt; TSharedRef\u0026lt;T, ESPMode::ThreadSafe\u0026gt; TWeakPtr\u0026lt;T, ESPMode::ThreadSafe\u0026gt; TSharedFromThis\u0026lt;T, ESPMode::ThreadSafe\u0026gt; These classes perform atomic operations on reference counts, which makes them slightly slower than default classes but operation is very similar to raw C++ pointers.\nReading and copying operations are always thread-safe. Writing and reset operations require synchronization for safety. Comments When passing shared pointers/references as method arguments, there is overhead due to reference counting and dereferencing. If possible, pass by const \u0026amp;. Shared pointers allow forward declaration of incomplete types. As mentioned, smart pointers and garbage collection in C++ (UObject Handling) are two separate memory management systems. ","date":"2024-03-05T17:31:11+09:00","image":"https://sangho0n.github.io/en/p/unreal-smart-pointers/img/unreal.svg","permalink":"https://sangho0n.github.io/en/p/unreal-smart-pointers/","title":"Unreal Smart Pointers"},{"content":"Sorting algorithms should be chosen based on criteria such as time complexity in the best, average, and worst cases, as well as memory usage and stability.\nThe speed of sorting algorithms based on comparisons cannot be faster than O(nlog(n)) in the worst case.\nList of Sorting Algorithms Covered in this Post Selection Sort Insertion Sort Bubble Sort Heap Sort Quick Sort Merge Sort Radix Sort Selection Sort One of the simplest algorithms. Since it is an in-place algorithm, it is suitable for environments where copying operations are very slow.\nAt each step, the array is scanned once, selecting the minimum (maximum) value among the unsorted elements and swapping it with the front element.\nAfter each step, the number of unsorted elements is reduced by one, and the same operation is repeated for the reduced array.\nIn-Place. Unstable.\nTime Complexity Case Complexity Best O(n^2) Worst O(n^2) Average O(n^2) Insertion Sort Divides one array into a sorted array and an unsorted array, increasing the size of the sorted array step by step and decreasing the size of the unsorted array.\nAn unsorted array\u0026rsquo;s front element is compared sequentially with the elements of the sorted array and inserted at the appropriate position.\nIn-Place. Stable.\nTime Complexity Case Complexity Best (Already sorted) O(n) Worst O(n^2) Average O(n^2) Bubble Sort At each step, the array is linearly searched, comparing adjacent elements and performing swap operations.\nIn-place. Stable.\nTime Complexity Case Complexity Best O(n^2) Worst O(n^2) Average O(n^2) Heap Sort A method of sorting using a max heap or min heap. It is possible to use a separate heap or make the given array a heap (In-place).\nThe operations of inserting/deleting elements in the heap are O(logn) (height of the heap), and these operations are repeated for the number of elements (twice; making a Heap + pulling elements one by one), so the total time complexity is O(nlogn).\nIn-Place. Unstable.\nTime Complexity Case Complexity Best O(nlogn) Worst O(nlogn) Average O(nlogn) Quick Sort Divides the array based on the pivot value into smaller values on the left and larger values on the right.\nFor each divided array, Quick Sort is performed iteratively until it cannot be divided further.\nIf the pivot is optimally selected at every moment, the given array is precisely divided in half every time. The worst case occurs when the pivot is consistently selected as the minimum (or maximum) value.\nIn-Place. Unstable.\nTime Complexity Case Complexity Best O(nlogn) Worst O(n^2) Average O(nlogn) Merge Sort One of the divide and conquer algorithms. The array is divided in half, and Merge Sort is performed on each divided array. Then, the sorted arrays are merged to obtain one large sorted array.\nUnlike other sorting algorithms, it has O(n) level of space complexity even in the best case.\nFor the purpose of optimizing the divided array, you can mix Merge Sort with another sorting algorithm (such as Insertion Sort) that is not Merge Sort (this may result in instability).\nnot In-Place. Stable.\nTime Complexity Case Complexity Best O(nlogn) Worst O(nlogn) Average O(nlogn) Radix Sort Unlike the previous algorithms, a sorting algorithm that operates without comparisons. Since the numbers are sorted based on digits, the digits must be sortable in lexicographical order.\nA kind of bucket sort.\nnot In-Place. Stable\nTime Complexity Let n be the number of digits to be sorted, d be the maximum number of digits, and k be the number of buckets (0~9 for numbers).\nBest, worst, and average cases are all O(d(n + k))\n","date":"2024-02-26T11:49:35+09:00","image":"https://sangho0n.github.io/en/p/summary-of-sorting-algorithms/img/algorithm_hu8666b0214ef6ef8b40207752073739fc_14421_120x120_fill_box_smart1_3.png","permalink":"https://sangho0n.github.io/en/p/summary-of-sorting-algorithms/","title":"Summary of Sorting Algorithms"},{"content":"\nStarting from Unreal Engine 5, the existing input mapping system has been deprecated. Let\u0026rsquo;s take a look at the Enhanced Input system that replaces it.\nTo effectively support complex input processing and runtime control remapping, the concept introduced from UE5 is Enhanced Input. It is an upgraded version of UE4\u0026rsquo;s default input system, providing backward compatibility as well. Not only does it handle input data processing, but it also allows functionalities such as radial dead zone, composite actions, combo attacks, etc., to be implemented in an asset-based environment.\nKey Concepts The Enhanced Input system has four key concepts:\nInput Action: Acts as a communication channel between the Enhanced Input system and project code. An input action can report up to three independent axis (floating point) values separate from the input that triggered itself. Input Mapping Context: Responsible for mapping user input to input actions. It can be dynamically added or removed for individual users and can have priorities. By applying one or more input mapping contexts to a player and assigning priorities, conflicts can be resolved even if multiple actions are triggered by the same input. e.g., when a button opens a door and another button opens a bag\nAdditionally, the following two concepts are elements that make input processing more flexible.\nModifier: Used to refine input values. It can apply a dead zone to ignore small movements or make input values smoother, among other operations. Modifiers that are already defined can be used, or developers can define their custom modifiers. Trigger: Determines whether to activate the input action based on processed data from modifiers or the result of other input actions. Input Actions Connects the Enhanced Input system with project code. To trigger an input action, you must add the input action to an input mapping context and register the input mapping context in the local player\u0026rsquo;s Enhanced Input Local Player Subsystem.\nTo make a Pawn react to the triggered input action, you need to control it using Blueprints or C++.\n1 2 3 4 5 6 7 8 9 10 11 12 void AMyCharacter::SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) { Super::SetupPlayerInputComponent(PlayerInputComponent); UEnhancedInputComponent* EnhancedInputComponent = CastChecked\u0026lt;UEnhancedInputComponent\u0026gt;(PlayerInputComponent); EnhancedInputComponent-\u0026gt;BindAction(MyAction, ETriggerEvent::Triggered, this, \u0026amp;AMyCharacter::MyAction); } void AMyCharacter::MyAction(const FInputActionValue\u0026amp; Value) { // do sth } Input Mapping Contexts In an input mapping context, you can map inputs to input actions. Once a mapping is completed, the context can be added or removed anytime to the local player\u0026rsquo;s Enhanced Input Local Player Subsystem.\n1 2 3 4 5 6 7 8 9 10 11 12 // do sth ... APlayerController* PlayerController = CastChecked\u0026lt;APlayerController\u0026gt;(GetController()); if (UEnhancedInputLocalPlayerSubsystem* Subsystem = ULocalPlayer::GetSubsystem\u0026lt;UEnhancedInputLocalPlayerSubsystem\u0026gt;(PlayerController-\u0026gt;GetLocalPlayer())) { Subsystem-\u0026gt;ClearAllMappings(); UInputMappingContext* NewMappingContext = NewCharacterControl-\u0026gt;InputMappingContext; if (NewMappingContext) { Subsystem-\u0026gt;AddMappingContext(NewMappingContext, 0); } } // do sth ... Modifier A modifier is a pre-processor that can adjust input values before sending them through the trigger. The Unreal Engine provides the following modifiers by default:\nTo create a new modifier, you need to create a class that inherits from the InputModifier class. And override the Modify Raw function. Directional Input One example of using modifiers effectively is implementing 2D directional input using a single input action. When creating a Third-Person Template project, examine the IA_Move and IMC_Default configurations as follows:\nKey Input Direction Scalar Value Modifier Desired Direction Vector w Up 1 Swizzle Input Axis Value (1, 0, 0) s Down 1 Swizzle Input Axis Value, Negate (-1, 0, 0) a Left 1 Negate (0, -1, 0) d Right 1 - (0, 1, 0) Looking at parts of the declaration and implementation of the UInputModifierSwizzleAxis class:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 UCLASS(NotBlueprintable, MinimalAPI, meta = (DisplayName = \u0026#34;Swizzle Input Axis Values\u0026#34;)) class UInputModifierSwizzleAxis : public UInputModifier { GENERATED_BODY() public: UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Settings) EInputAxisSwizzle Order = EInputAxisSwizzle::YXZ; protected: virtual FInputActionValue ModifyRaw_Implementation(const UEnhancedPlayerInput* PlayerInput, FInputActionValue CurrentValue, float DeltaTime) override; virtual FLinearColor GetVisualizationColor_Implementation(FInputActionValue SampleValue, FInputActionValue FinalValue) const override; }; FInputActionValue UInputModifierSwizzleAxis::ModifyRaw_Implementation(const UEnhancedPlayerInput* PlayerInput, FInputActionValue CurrentValue, float DeltaTime) { FVector Value = CurrentValue.Get\u0026lt;FVector\u0026gt;(); switch (Order) { case EInputAxisSwizzle::YXZ: Swap(Value.X, Value.Y); break; // other cases... } return FInputActionValue(CurrentValue.GetValueType(), Value); } With the default Order being YXZ, passing through a scalar value of 1 through the modifier results in a value of (1.0f, 0.0f, 0.0f). Setting up the modifier as described in the table allows scalar values to be converted into the desired direction vectors.\nTrigger The trigger verifies processed values from modifiers and other input actions to determine whether the input action should be activated. However, the Chord Action trigger is an exception and is triggered through another input action. The images below showcase the default triggers.\nThere are three trigger types: Explicit, Implicit, and Blocker.\nExplicit: Input succeeds when the trigger condition is met. Implicit: Input succeeds if the trigger condition is met along with all implicit trigger types. Blocker: Input fails when the trigger condition is met. The table below shows the type of triggers based on their classes:\nTrigger Class (cpp) Type UInputTrigger(default) Explicit UInputTriggerCombo Implicit UInputTriggerChordAction Implicit UInputTriggerChordBlocker Blocker After processing user input, the trigger can return one of three states:\nNone: The conditions were not met, and the trigger failed. Ongoing: The conditions were partially met and the trigger is still in progress but has not yet succeeded. Triggered: All input trigger conditions were met, and the input trigger succeeded. By inheriting the InputTrigger class or the InputTriggerTimedBase class, you can create custom triggers. The InputTriggerTimedBase class checks if input has been sustained for a certain period and returns the Ongoing state during that time. However, as the InputTriggerTimedBase class does not return Triggered even if the conditions are met, when creating a new trigger by inheriting it, you must override the GetTriggerType and UpdateState methods to return the desired states.\n","date":"2024-02-14T17:44:19+09:00","image":"https://sangho0n.github.io/en/p/unreal-enhanced-input/img/unreal.svg","permalink":"https://sangho0n.github.io/en/p/unreal-enhanced-input/","title":"Unreal Enhanced Input"},{"content":"Based on lectures by Lee Geuk Woo and documents summarized by other developers.\nFor detailed and accurate information, please refer to the links above.\nSeries Basic of GAS Unreal GAS Overview \u0026lt;- Current post Getting Started with Unreal GAS Basic of Creating GAS Characters Input Handling in Unreal GAS Implementing Continuous Attacks in Unreal GAS Implementing Attack Judgment System in Unreal GAS Attributes and Gameplay Effects Unreal GAS Character Attributes Unreal GAS Gameplay Effects Linking Attributes to UI in Unreal GAS Utilization of GAS Implementing Item Boxes in Unreal GAS Implementing Area of Effect Skills in Unreal GAS Gameplay Ability System A framework that provides the functionality of actor abilities and interaction among actors through abilities. Advantages Flexibility, scalability: Easily applicable to a variety of complex game designs. Modular system: Minimizes dependencies for each functionality. Network support Data-driven design Completion: Games like Fortnite are already using it. Disadvantages Learning curve Overhead in small-scale projects Suitable for creating large-scale RPG and multiplayer games\nComponents Gameplay Ability: Implementing character abilities based on cost and cooldown (optional). Attributes: Manipulating actor characteristics. Gameplay Effects: Changes in actor state based on ability activation. Gameplay Tags: Assigning tags to actors. Gameplay Cues: Visual effects. Replication for all of the above. GAS in Multiplayer Games The GAS plugin supports client-side prediction, allowing the activation of abilities and effects without server permission.\nAbility activation Playing animation montages Modifying attributes Assigning gameplay tags Executing gameplay cues Manipulating movement through CharacterMovementComponent and RootMotionSource functions Blueprint vs C++ GAS should be implemented using C++, but it is possible to implement GameplayAbilities and GameplayEffects using blueprints.\n","date":"2024-02-14T13:53:44+09:00","image":"https://sangho0n.github.io/en/p/unreal-gas-overview/img/unreal.svg","permalink":"https://sangho0n.github.io/en/p/unreal-gas-overview/","title":"Unreal GAS Overview"},{"content":"Above is the translation of the document from Korean to English:\ntitle: \u0026ldquo;Implementation of Unreal GAS Attack Judgment System\u0026rdquo; date: 2024-04-03T13:53:44+09:00 image: img/unreal.svg\ntags: [\u0026ldquo;Unreal\u0026rdquo;, \u0026ldquo;언리얼\u0026rdquo;, \u0026ldquo;UE\u0026rdquo;, \u0026ldquo;GAS\u0026rdquo;, \u0026ldquo;Ability\u0026rdquo;] categories: [\u0026ldquo;Unreal\u0026rdquo;] series: [\u0026ldquo;Gameplay Ability System (GAS)\u0026rdquo;]\nThis content is summarized based on the lectures by Lee Deuk-woo and documents compiled by other developers.\nFor detailed and accurate information, please refer to the above links.\nSeries GAS Fundamentals Unreal GAS Overview Getting Started with Unreal GAS GAS Character Creation Basics Unreal GAS Input Processing Implementing Continuous Attacks in Unreal GAS Implementation of Unreal GAS Attack Judgment System\u0026lt;- Current Post Attributes and Gameplay Effects Unreal GAS Character Attributes Unreal GAS Gameplay Effects Linking Unreal GAS Attributes with UI Utilization of GAS Implementing Unreal GAS Item Box Implementing Wide-range Skills in Unreal GAS This post explores sending attack judgment timing to GAS using Gameplay Event and TargetActor, implementing attack judgment within the GAS.\nGameplay Event In GAS, there is a functionality called GameplayEvent that notifies GAS of a specific event by specifying a GameplayTag. The table below shows what can be done in GAS using GameplayEvent.\nMethod Description UAbilitySystemBlueprintLibrary::SendGameplayEventToActor When a specific event occurs, it notifies the actor about it and can activate GameplayAbility using it. UAbilityTask_WaitGameplayEvent::WaitGameplayEvent It waits for the task until a specific event occurs. Various information related to the event can be passed to the Ability waiting for it. We will look into how to activate an ability for attack judgment using the SendGameplayEventToActor method. We will implement this in the following sequence:\nGenerate Gameplay Tag for Gameplay Events Create Custom Animation Notify and Assign to Animation Create a New Gameplay Ability and Assign Trigger Event Tags Creating Event Tags Create a Gameplay Tag for events as Character.Action.PunchKick.\nCreating and Relaying Notifies 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class ARENABATTLEGAS_API UAnimNotify_OnPunchKick : public UAnimNotify { GENERATED_BODY() public: UAnimNotify_OnPunchKick(); protected: virtual FString GetNotifyName_Implementation() const override; virtual void Notify(USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, const FAnimNotifyEventReference\u0026amp; EventReference) override; UPROPERTY(EditAnywhere) FGameplayTag TriggerGameplayTag; }; FString UAnimNotify_OnPunchKick::GetNotifyName_Implementation() const { return TEXT(\u0026#34;OnGASAttackHit\u0026#34;); } void UAnimNotify_OnPunchKick::Notify(USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, const FAnimNotifyEventReference\u0026amp; EventReference) { Super::Notify(MeshComp, Animation, EventReference); if(MeshComp) { AActor* Owner = MeshComp-\u0026gt;GetOwner(); if(Owner) { FGameplayEventData EmptyPayload; UAbilitySystemBlueprintLibrary::SendGameplayEventToActor(Owner, TriggerGameplayTag, EmptyPayload); } } } Use the SendGameplayEventToActor method to relay the event during the animation to the Actor.\nNext steps involve the creation and utilization of TargetActor in GAS for attack judgment. This includes detecting possible target actors within a specified range in front of the player during an attack. By following the outlined steps and sequence, you can enhance attack judgment in your game with GAS.\nPlease let me know if you need any further information or clarifications!\n","date":"0001-01-01T00:00:00Z","permalink":"https://sangho0n.github.io/en/p/","title":""},{"content":"This post is an overview of how to handle input in Unreal GAS.\nSeries GAS Basics Unreal GAS Overview Getting Started with Unreal GAS Creating Characters with GAS Basics Unreal GAS Input Handling \u0026lt;- Current Post Implementing Continuous Attacks in Unreal GAS Implementing Attack Judgment System in Unreal GAS Attributes and Gameplay Effects Unreal GAS Character Attributes Unreal GAS Gameplay Effects Linking Unreal GAS Attributes with UI Utilizing GAS Implementing Unreal GAS Item Box Implementing Broad Area Skill in Unreal GAS In this post, we explore how to activate abilities (like jump and attack) through user input.\nOwnerActor and AvatarActor In the Gameplay Ability System, OwnerActor refers to the actor with AbilitySystemComponent, while AvatarActor represents the physical representation of AbilitySystemComponent.\nIt\u0026rsquo;s common practice to set PlayerState as the OwnerActor since a character\u0026rsquo;s abilities are often activated based on its current state. In this post, we attach the ability system to the PlayerState and set the OwnerActor and AvatarActor. (Note: Both actors should implement IAbilitySystemInterface even if Owner and Avatar are different.)\nFGameplayAbilitySpec and FGameplayAbilitySpecHandle To grant abilities to the AbilitySystemComponent, we need to create an FGameplayAbilitySpec structure and register it using the GiveAbility or GiveAbilityAndActivateOnce method.\nOnce registered, abilities can be accessed through the FGameplayAbilitySpecContainer ActivatableAbilities within the component. The FGameplayAbilitySpecHandle structure is used to uniquely identify granted abilities.\nInputID To handle input bindings, we can leverage EnhancedInputComponent\u0026rsquo;s BindAction along with the InputID contained in FGameplayAbilitySpec. This approach simplifies generic input processing for abilities like jump and attack.\nInstancingPolicy InstancingPolicy determines how gameplay abilities are instantiated during execution. For jump abilities, we align with the default class policy.\nAbility Task and Gameplay Cue Ability Tasks and Gameplay Cues are essential for executing gameplay-related operations and non-gameplay tasks like SFX, VFX, or Camera Shake. Ability Tasks are ideal for actions that need to run only when the ability is active, like animations.\nIn our case, we utilize UAbilityTask_PlayMontageAndWait to play attack animations as part of the gameplay ability.\nDebugging To debug ability handling, we create a blueprint class inheriting from our game ability class in Unreal Engine. This blueprint class allows easy assignment of gameplay tags without the need for source code compilation. We also call the console command showdebug abilitysystem to visualize ability system debugging in the PIE viewport.\nThrough this process, we can efficiently handle user input to trigger various abilities in the game.\n","date":"0001-01-01T00:00:00Z","permalink":"https://sangho0n.github.io/en/p/","title":""}]