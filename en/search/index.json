[{"content":"This summary by Lee Deok-woo and this document compiled by another developer were referenced.\nFor detailed and accurate information, please refer to the above links.\nSeries\nOverview of Unreal GAS Starting Unreal GAS \u0026lt;- Current Post In this post, we will explore the usage of the GAS framework by implementing actor movement through three methods and examining the differences of each method.\nExtending actor functionality Using the Game Ability System Using Game Ability System with Gameplay Tags The fountain actor and its movement will be based on a 3-second stationary rotation/stop.\nExtending Actor Functionality Implementing movement without the GAS framework by directly using URotatingMovementComponent:\n1 // C++ code snippet provided Using Game Ability System To implement movement using the GAS framework, two key concepts need to be understood:\nAbility System Component Game Ability Ability System Component Manages the gameplay ability system Only one can be attached per actor Allows an actor to trigger Gameplay Abilities through it Enables interactions between actors with this component through the Game Ability System Game Ability An action that can be registered in the Ability System Component and triggered Activation process: Registration in Ability System Component: AbilitySystemComponent-\u0026gt;GiveAbility() Activation: AbilitySystemComponent-\u0026gt;TryActivateAbility() Utilizes SpecHandle, ActorInfo, ActivationInfo to implement requirements internally Key methods: CanActivateAbility ActivateAbility CancelAbility EndAbility By using these concepts, the same movement can be implemented as shown below.\nCreating an Ability Class by inheriting from Gameplay Ability 1 // C++ code snippet provided Attaching components to the actor and implementing the interface 1 // C++ code snippet provided Registering and triggering abilities with attached components 1 // C++ code snippet provided Using Game Ability System + Gameplay Tags When using only the Game Ability System without gameplay tags, the full advantages of the GAS framework cannot be utilized. Let\u0026rsquo;s understand what Gameplay Tags are:\nGameplay Tags FGameplayTag represents a hierarchical name structure like Parent.Child.Grandchild.... These are managed by GameplayTagManager. By utilizing these tags, it becomes easier to classify and track the status of classes effectively.\nInstead of using bool or enum values and condition statements to track status, Gameplay Tags can be used to check if an object has a certain tag, simplifying state monitoring.\nThe GAS framework is very friendly towards Gameplay Tags. Since UAbilitySystemComponent implements IGameplayTagAssetInterface, tags can be specified directly in the Ability System Component, and several states of GameplayAbility can be managed with Gameplay TagContainer.\nUsing Gameplay Tags eliminates the need for specific information about Gameplay Ability classes in actor classes, maintaining low code dependency.\nBy using Gameplay Tags, the same requirements can be implemented as shown below.\nCreating Tags 1 2 // DefaultGameplayTags.ini // Tags creation snippet Writing macros for easier access to tags 1 2 // ABGameplayTag.h // Macros snippet Registering tags with Gameplay Abilities 1 // C++ code snippet provided Registering and activating abilities using tags 1 // C++ code snippet provided After creating a Blueprint class that inherits from the AABGASFountain cpp class, simply add the appropriate activities to the Abilities in the Details panel.\nSummary Implemented the rotating fountain using three methods:\nExtending actor functionality GAS: Creating a new class (ability) to separate functionality from the actor GAS + Gameplay Tags: Using tags to remove dependencies between actors and abilities Benefits of using GAS and Gameplay Tags together:\nMinimized actor\u0026rsquo;s role Reduced dependencies. Easier maintenance and higher reusability Improved scalability + easier collaboration with other professions ","date":"2024-03-18T15:58:25+09:00","image":"https://sangho0n.github.io/en/p/starting-unreal-gas/img/unreal.svg","permalink":"https://sangho0n.github.io/en/p/starting-unreal-gas/","title":"Starting Unreal GAS"},{"content":"A post to revive memories faded by using other languages. In this post, we\u0026rsquo;ll dive into inheritance relationships and the virtual keyword in C++.\nInheritance Unlike other object-oriented languages like Java and C#, C++ allows specifying access specifiers during inheritance.\n1 2 // syntax class Derived : \u0026lt;access_specifier\u0026gt; Parent When inheriting from a base class, this specifies how the base class\u0026rsquo;s elements will be received. Think of this as substituting elements specified less strictly by the access_specifier with those of the specified type during inheritance.\nLet\u0026rsquo;s examine three classes inheriting from the following class:\n1 2 3 4 5 6 7 8 9 class Base { public: int pubInt = 1; private: int privInt = 2; protected: int protInt = 3; }; Public Used to represent an is-a relationship. It follows the access specifier of the parent.\n1 2 3 4 5 6 7 8 9 10 class Pub : public Base // is-a { public: Pub() { pubInt = 1; // public //privInt = 2; // Cannot access private from parent class protInt = 3; // protected } }; Hence, external access is limited to the pubInt, which was public in the parent class.\n1 2 3 4 Pub* pub = new Pub(); cout \u0026lt;\u0026lt; pub-\u0026gt;pubInt \u0026lt;\u0026lt; endl; //cout \u0026lt;\u0026lt; pub-\u0026gt;privInt \u0026lt;\u0026lt; endl; // Error: ‘int Base::privInt’ is private within this context //cout \u0026lt;\u0026lt; pub-\u0026gt;protInt \u0026lt;\u0026lt; endl; // Error: ‘int Base::protInt’ is protected within this context Private Used to represent an is-implemented-in-terms-of relationship (default in C++). Private inheritance restricts access to the base class\u0026rsquo;s private members but inherits public and protected ones.\n1 2 3 4 5 6 7 8 9 10 class Priv : private Base // is-implemented-in-terms-of { public: Priv() { pubInt = 1; // public -\u0026gt; private //privInt = 2; // Cannot access private from parent class protInt = 3; // protected -\u0026gt; private } }; Thus, external access to any member of the parent class is disallowed.\n1 2 3 4 Priv* priv = new Priv(); //cout \u0026lt;\u0026lt; priv-\u0026gt;pubInt \u0026lt;\u0026lt; endl; // Error: ‘int Base::pubInt’ is inaccessible within this context //cout \u0026lt;\u0026lt; priv-\u0026gt;privInt \u0026lt;\u0026lt; endl; // Error: ‘int Base::privInt’ is private within this context //cout \u0026lt;\u0026lt; priv-\u0026gt;protInt \u0026lt;\u0026lt; endl; // Error: ‘int Base::protInt’ is protected within this context Additionally, even new classes inheriting from this cannot access any parent class members.\n1 2 3 4 5 6 7 8 class GrandChild : Priv { public: GrandChild() { // Unable to access any member of Base } }; Protected Similar to private inheritance in that it indicates an is-implemented-in-terms-of relationship. It changes the parent class\u0026rsquo;s public elements to protected during inheritance.\n1 2 3 4 5 6 7 8 9 10 class Prot : protected Base // is-implemented-in-terms-of { public: Prot() { pubInt = 1; // public -\u0026gt; protected //privInt = 2; // Error: ‘int Base::privInt’ is private within this context protInt = 3;// protected } }; Therefore, external access to any member of the Base class is restricted.\n1 2 3 4 Prot* prot = new Prot(); //cout \u0026lt;\u0026lt; prot-\u0026gt;pubInt \u0026lt;\u0026lt; endl; // Error: ‘int Base::pubInt’ is inaccessible within this context //cout \u0026lt;\u0026lt; prot-\u0026gt;privInt \u0026lt;\u0026lt; endl; // Error: ‘int Base::privInt’ is private within this context //cout \u0026lt;\u0026lt; prot-\u0026gt;protInt \u0026lt;\u0026lt; endl; // Error: ‘int Base::protInt’ is protected within this context However, unlike private, new classes inheriting from this can access members of the parent class.\n1 2 3 4 5 6 7 8 9 class GrandChild2 : Prot { public: GrandChild2() { pubInt = 1; // because it is specified protected protInt = 3; // because it is specified protected } }; However, in the code above, because private inheritance was used by default, external access to GrandChild2\u0026rsquo;s pubInt and protInt is prevented.\nCasting Here is support for casting in each case:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int main() { // upcasting check Base *ptr1, *ptr2, *ptr3; ptr1 = new Pub(); //ptr2 = new Priv(); // Error: ‘Base’ is an inaccessible base of ‘Priv’ //ptr3 = new Prot(); // Error: ‘Base’ is an inaccessible base of ‘Prot’ // downcasting check Base* base = new Base(); Pub* pub_down = static_cast\u0026lt;Pub*\u0026gt;(base); // Checked at compile time. Does not consider polymorphism // Pub* pub_down = dynamic_cast\u0026lt;Pub*\u0026gt;(base); // Error because there is no virtual function (source type is not polymorphic) // Priv* priv_down = static_cast\u0026lt;Priv*\u0026gt;(base); // Error: ‘Base’ is an inaccessible base of ‘Priv’ // Prot* prot_down = static_cast\u0026lt;Prot*\u0026gt;(base); // Error: ‘Base’ is an inaccessible base of ‘Prot’ delete ptr1, ptr2, ptr3, pub_down, base; return 0; } For those familiar with other languages or those who haven\u0026rsquo;t deeply thought about access specifiers in inheritance while developing, they may be curious about what non-public inheritance is used for to express it. Let\u0026rsquo;s find out more about is-implemented-in-terms-of in the following sections.\nIs-Implemented-In-Terms-Of In general programming languages, is-a relationships are represented using inheritance (public inheritance in the case of C++) and has-a relationships are represented using composition (containment, aggregation) to describe relationships between objects. In C++, along with the above two concepts, there is a specific term called is-implemented-in-terms-of to describe relationships between objects.\nAs the name suggests, is-implemented-in-terms-of indicates that when an object uses another object to function. Therefore, is-implemented-in-terms-of can also be represented using composition in C++. So, what differentiates has-a from is-implemented-in-terms-of? The distinguishing factor between the two relationships lies in the domain.\nThe has-a relationship is used when modeling application domains easily recognizable in everyday life. For instance, in the application domain of people, means of communication, and means of transportation can be modeled as has-a relationships. On the other hand, is-implemented-in-terms-of signifies the space of software implementation. Examples include buffers, mutexes, search trees, etc.\nIn C++, relationships involving has-a can be implemented using composition, similar to other languages. On the contrary, the is-implemented-in-terms-of relationship can be implemented using composition similar to has-a or through non-public inheritance.\nThe question arises, in which scenarios is it more appropriate to use non-public inheritance for implementation, and when to use composition? Let\u0026rsquo;s look at examples of classes implemented in both ways and explore which approach is preferable.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 template \u0026lt;class T\u0026gt; class MyList { public: bool Insert( const T\u0026amp;, size_t index ); T Access( size_t index ) const; size_t Size() const; private: T* buf_; size_t bufsize_; }; template \u0026lt;class T\u0026gt; class MySet1 : private MyList\u0026lt;T\u0026gt; { public: bool Add( const T\u0026amp; ); // calls Insert() T Get( size_t index ) const; // calls Access() using MyList\u0026lt;T\u0026gt;::Size; //... }; template \u0026lt;class T\u0026gt; class MySet2 { public: bool Add( const T\u0026amp; ); // calls impl_.Insert() T Get( size_t index ) const; // calls impl_.Access() size_t Size() const; // calls impl_.Size(); //... private: MyList\u0026lt;T\u0026gt; impl_; }; Implementation via Inheritance vs Implicit Composition As seen from the example code above, anything achievable through single composition can also be implemented through inheritance. Why then, does C++ differentiate between is-implemented-in-terms-of and has-a?\nThe reason is that there are cases where something implementable via non-public inheritance is not achievable through single composition. The following 5 items indicate each scenario (roughly listed from common to less common):\nWhen needing to access protected members. Generally, used when calling protected methods (or constructors) is necessary. When needing to override virtual functions. If the base class has a pure virtual function, composition cannot be used. When one implementation needs to be created before (or destroyed after) another. When multiple implementations are interdependent, and the life cycle of one implementation needs to encompass the other. If the implementation includes a critical section or data transaction requiring a lock, it must cover the entire lifetime of the other implementations. When sharing a virtual base class or requiring changes to virtual base class creation. Finally, although distinct from is-implemented-in-terms-of, non-public inheritance has one more characteristic that composition alone cannot provide.\nWhen ‘Restricted Polymorphism’ is necessary; for cases where only some code needs Liskov Substitution. Public inheritance always enables Liskov substitution. Non-public inheritance, however, can represent a \u0026rsquo;limited\u0026rsquo; is-a relationship. While it may not appear polymorphic to an external observer using non-public inheritance (Derived is not a Base), polymorphism may be required within member functions or by friend classes. Let\u0026rsquo;s examine the code for MySet and MyList. In this case:\nMyList does not have protected members. MyList is not an abstract class. MySet does not inherit from any class except MyList. MyList does not inherit the virtual base class which MySet needs or must override. MySet is not a MyList. Since none of these five situations apply, it is preferable to implement through composition rather than inheritance. Inheritance can potentially expose unnecessary information to the child classes and create undesired dependencies not required for the implementation.\nWhile compiling this post, I realized that C++ has quite a variety of ways to implement object relationships compared to other languages. At the same time, it does not only look easy to understand but also seems to have many parts that should not be casually overused due to violating the principles of object-oriented programming.\nPolymorphism Polymorphism is the ability of an operator or method with the same name to perform different tasks. In C++, polymorphism can be achieved through operator/method overloading and method overriding. Among these, method overriding is used in conjunction with the virtual keyword. In this post, let\u0026rsquo;s understand how the virtual keyword is used when implementing method overriding.\nVirtual In C++, the virtual keyword is used when declaring virtual functions and when inheriting a virtual base class.\n1 2 3 4 5 // syntax virtual [type-specifiers] member_function_declarator class Class_Name : virtual [access-specifier] Base_Class_Name class Class_Name : [access-specifier] virtual Base_Class_Name Virtual Function Virtual functions are used for defining functions in the base class that can be overridden in a derived class to achieve polymorphism. When a function is declared as virtual, it is registered in a vTable (virtual table) generated by the compiler for each class, and during runtime, it accesses this vTable (vPtr) to decide which function to call.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 // C++ program to show the working of vtable and vptr #include \u0026lt;iostream\u0026gt; using namespace std; // base class class Base { public: virtual void function1() { cout \u0026lt;\u0026lt; \u0026#34;Base function1()\u0026#34; \u0026lt;\u0026lt; endl; } virtual void function2() { cout \u0026lt;\u0026lt; \u0026#34;Base function2()\u0026#34; \u0026lt;\u0026lt; endl; } virtual void function3() { cout \u0026lt;\u0026lt; \u0026#34;Base function3()\u0026#34; \u0026lt;\u0026lt; endl; } }; // class derived from Base class Derived1 : public Base { public: // overriding function1() void function1() { cout \u0026lt;\u0026lt; \u0026#34;Derived1 function1()\u0026#34; \u0026lt;\u0026lt; endl; } // not overriding function2() and function3() }; // class derived from Derived1 class Derived2 : public Derived1 { public: // again overriding function2() void function2() { cout \u0026lt;\u0026lt; \u0026#34;Derived2 function2()\u0026#34; \u0026lt;\u0026lt; endl; } // not overriding function1() and function3() }; // driver code int main() { // defining base class pointers Base* ptr1 = new Base(); Base* ptr2 = new Derived1(); Base* ptr3 = new Derived2(); // calling all functions ptr1-\u0026gt;function1(); ptr1-\u0026gt;function2(); ptr1-\u0026gt;function3(); ptr2-\u0026gt;function1(); ptr2-\u0026gt;function2(); ptr2-\u0026gt;function3(); ptr3-\u0026gt;function1(); ptr3-\u0026gt;function2(); ptr3-\u0026gt;function3(); // deleting objects delete ptr1; delete ptr2; delete ptr3; return 0; } // Console Output Base function1() Base function2() Base function3() Derived1 function1() Base function2() Base function3() Derived1 function1() Derived2 function2() Base function3() Virtual Base Class C++ allows multiple inheritances. When an instance is created, the space allocated to A will attempt to be created twice. Fortunately, the compiler detects this and flags it as an error. In fact, such inheritance structures can lead to the diamond problem, so it is not a recommended inheritance structure.\nIf you need to call A\u0026rsquo;s show() even in this inheritance situation, you can make B and C inherit A as a virtual base.\n1 2 3 4 5 6 class B : virtual public A { }; class C : public virtual A { }; // Both syntaxes are valid References \u0026ldquo;Effective C++” Third Edition by Scott Meyers. Uses and Abuses of Inheritance What is the difference between public, private, and protected inheritance? virtual (C++) C++ Polymorphism vTable And vPtr in C++ Virtual base class in C++ ","date":"2024-03-08T11:12:45+09:00","image":"https://sangho0n.github.io/en/p/c-inheritance-and-the-virtual-keyword/img/cpp.svg","permalink":"https://sangho0n.github.io/en/p/c-inheritance-and-the-virtual-keyword/","title":"C++ Inheritance and the Virtual Keyword"},{"content":"Based on the official documentation, this article provides an interpretation of the content. (Many interpretations included) There may be differences from reality. Your feedback is appreciated.\nUnreal provides implementations of various smart pointers used in C++. The provided classes include Shared Pointer, Weak Pointer, Unique Pointer, and an additional unique type called Shared Reference. Since UObject is managed by a separate memory tracking system, instances of classes that inherit from UObject cannot be wrapped with smart pointers. (A memory reclaiming structure different from garbage collection; RAII pattern)\nTypes Type Usage TSharedPtr Shared Pointer is a class that owns the object it wraps. It prevents the object from being destroyed by external factors while it is owned. Ultimately, when the number of shared pointers (or references) owning the object becomes 0, it manages the object\u0026rsquo;s destruction. Shared pointers can exist even when they are not wrapping any object. When the wrapped object is not null, a shared reference can be created at any time. TSharedRef Similar to a shared pointer but differs in that the wrapped object cannot be null. Since null is not possible, it can be converted to a shared pointer at any time, and the pointed object is always in a valid state. It is used when you want to clearly define ownership or ensure that the object is not null. TWeakPtr Similar to a shared pointer but does not own the object, therefore does not impact the object\u0026rsquo;s lifecycle. It can be useful for breaking reference cycles but since the object being referenced can become null at any time without warning, it is better to convert it to a shared pointer for safe access. TUniquePtr A unique pointer owns the object exclusively. It can transfer ownership but cannot be shared. Attempting to copy a unique pointer results in a compile error. When it goes out of scope, it automatically releases the object it owns from memory. Reference cycle: A phenomenon that occurs when two or more objects reference each other. If the reference count does not reach 0, the objects will not be released, leading to memory leaks.\nBenefits Benefit Explanation Prevention of Memory Leaks By automatically destroying objects, it prevents memory leaks. Weak References Solves circular reference problems and prevents dangling pointers. Thread Safety Assurance (optional) Additional code can be written to ensure thread safety when needed. (Overhead exists) Runtime Safety Shared references cannot be null and can release references at any time, ensuring runtime stability. Intention Conveyance Owners and observers can be easily distinguished. Memory Advantages All these functions can be performed with just double the size of a pointer variable in C++ (based on 64-bits; including 16 bytes for reference control). However, a unique pointer has the same size as a C++ pointer. Owner manages and controls the lifespan of the object. Through shared pointers and unique pointers, ownership of the object is maintained, and when no longer needed, the object is released from memory. Observers reference the object but do not own it (Weak pointers). When the owner of the object deletes it, the observer should automatically become null.\nHelper Classes and Functions Helper Explanation Classes TSharedFromThis Inheriting from TSharedFromThis adds the AsShared and SharedThis methods to the class. These methods help in obtaining a TSharedRef for the object. Functions MakeShared and MakeShareable MakeShared function creates a TSharedPtr from a regular C++ pointer. This function allocates a new object instance and reference controller in a single memory block. The object must have a public constructor. MakeShareable is also used to create a TSharedPtr from a C++ pointer. This function works even when the object\u0026rsquo;s constructor is private. This allows you to obtain ownership of an object you did not create, and additionally, you can provide custom logic when the destructor is called. Due to these additional features, it allows for more flexible programming compared to MakeShared, but it also comes with overhead. StaticCastSharedRef and StaticCastSharedPtr Utility functions that support static casting (mainly downcasting) ConstCastSharedRef and ConstCastSharedPtr Each returns a reference or a pointer type variable with const-ness being mutable. Example of adding additional logic to the destructor using MakeShareable\n1 2 3 4 5 6 TSharedPtr\u0026lt;FOnlineSession\u0026gt; SharedPtr = MakeShareable(new FOnlineSession(), [](FOnlineSession* ObjToDelete)-\u0026gt; void { // Implement custom destructor logic ObjToDelete-\u0026gt;PerformAdditionalCleanup(); delete ObjToDelete; }); Implementation Details Unreal\u0026rsquo;s smart pointer library is implemented to preserve both functionality and efficiency.\nSpeed While smart pointers are very useful in high-level systems like resource management and tool programming, they are not suitable for low-level engine code like rendering due to their slower performance compared to C++ raw pointers.\nUnreal\u0026rsquo;s smart pointer library has the following performance benefits:\nAll operations are performed in constant time. In Shipping builds, dereferencing in most smart pointers is as fast as in C++ raw pointers. Copying smart pointers does not require new memory allocation. Thread-safe smart pointers do not require locking. However, there are also drawbacks:\nCreating and copying new smart pointers have overhead compared to C++ raw pointers. Managing reference counts adds an additional overhead to basic operations. Some smart pointers use more memory than C++ raw pointers. Reference controllers require two heap memory allocations. Using MakeShared instead of MakeSharable can avoid the second memory allocation. Intrusive Accessors Typically, the instance referenced by a smart pointer is not aware of the smart pointers referencing it (known as non-intrusive). However, Unreal\u0026rsquo;s smart pointer library allows accessors to obtain references from smart pointers that reference themselves through TSharedFromThis.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class FRegistryObject; class FMyBaseClass: public TSharedFromThis\u0026lt;FMyBaseClass\u0026gt; { virtual void RegisterAsBaseClass(FRegistryObject* RegistryObject) { // Access a shared reference to \u0026#39;this\u0026#39;. // We are directly inherited from \u0026lt;TSharedFromThis\u0026gt; , so AsShared() and SharedThis(this) return the same type. TSharedRef\u0026lt;FMyBaseClass\u0026gt; ThisAsSharedRef = AsShared(); // RegistryObject expects a TSharedRef\u0026lt;FMyBaseClass\u0026gt;, or a TSharedPtr\u0026lt;FMyBaseClass\u0026gt;. TSharedRef can implicitly be converted to a TSharedPtr. RegistryObject-\u0026gt;Register(ThisAsSharedRef); } }; class FMyDerivedClass : public FMyBaseClass { virtual void Register(FRegistryObject* RegistryObject) override { // We are not directly inherited from TSharedFromThis\u0026lt;\u0026gt;, so AsShared() and SharedThis(this) return different types. // AsShared() will return the type originally specified in TSharedFromThis\u0026lt;\u0026gt; - TSharedRef\u0026lt;FMyBaseClass\u0026gt; in this example. // SharedThis(this) will return a TSharedRef with the type of \u0026#39;this\u0026#39; - TSharedRef\u0026lt;FMyDerivedClass\u0026gt; in this example. // The SharedThis() function is only available in the same scope as the \u0026#39;this\u0026#39; pointer. TSharedRef\u0026lt;FMyDerivedClass\u0026gt; AsSharedRef = SharedThis(this); // RegistryObject will accept a TSharedRef\u0026lt;FMyDerivedClass\u0026gt; because FMyDerivedClass is a type of FMyBaseClass. RegistryObject-\u0026gt;Register(ThisAsSharedRef); } }; class FRegistryObject { // This function will accept a TSharedRef or TSharedPtr to FMyBaseClass or any of its children. void Register(TSharedRef\u0026lt;FMyBaseClass\u0026gt;); }; As mentioned, by inheriting from TSharedFromThis, the class can use AsShared and SharedThis methods to obtain a shared pointer (TSharedRef) for its instance. However, in cases where a class does not directly inherit TSharedFromThis, the return value will differ. It is advisable to set the shared pointer of the base class directly when using a factory class or a method that takes a shared reference (such as FRegistryObject::Register(TSharedRef\u0026lt;FMyBaseClass\u0026gt;)).\nNote that using AsShared and SharedThis in the constructor can lead to crashes or assertions, as they return the smart pointer of the instantiated object.\nType Casting Unreal\u0026rsquo;s smart pointer library allows for casting similar to C++ pointers.\nUp Casting: Implicitly performed, similar to C++ raw pointers (automatic conversion from a base class pointer to a derived class pointer). Const Casting: Perform using ConstCastSharedPtr/Ref methods. Static Casting: Perform using StaticCastSharedPtr/Ref methods (mainly downcasting). Dynamic Casting: Not supported as there is no runtime type information (RTTI). 1 2 3 4 5 6 TSharedPtr\u0026lt;FDragDropOperation\u0026gt; Operation = DragDropEvent.GetOperation(); // Some code for validating that the FDragDropOperation is actually an FAssetDragDropOp through other means... // We can now cast with StaticCastSharedPtr. TSharedPtr\u0026lt;FAssetDragDropOp\u0026gt; DragDropOp = StaticCastSharedPtr\u0026lt;FAssetDragDropOp\u0026gt;(Operation); Thread Safety By default, smart pointers are only safe in a single-threaded environment. If you want thread-safe versions, you can use the following classes:\nTSharedPtr\u0026lt;T, ESPMode::ThreadSafe\u0026gt; TSharedRef\u0026lt;T, ESPMode::ThreadSafe\u0026gt; TWeakPtr\u0026lt;T, ESPMode::ThreadSafe\u0026gt; TSharedFromThis\u0026lt;T, ESPMode::ThreadSafe\u0026gt; These classes perform atomic operations on reference counts, making them slightly slower than the default classes but operationally very similar to C++ raw pointers.\nReading and copying operations are always thread-safe. Writing and resetting operations must be synchronized for safety. Additional Notes When passing shared pointers/references as method arguments, there is overhead due to reference counting and dereferencing. If possible, pass them as const\u0026amp;. Shared pointers allow forward declaration for incomplete classes. As mentioned earlier, smart pointers and garbage collection (UObject Handling) are separate memory management systems. Forward declaration example:\n1 2 3 4 5 6 7 8 // Forward declaration class IncompleteType; // Shared pointer for the forward-declared type TSharedPtr\u0026lt;IncompleteType\u0026gt; incompleteTypePtr; // When the definition of IncompleteType is complete, you can create a shared pointer for that type TSharedPtr\u0026lt;IncompleteType\u0026gt; incompleteTypePtr2 = MakeShared\u0026lt;IncompleteType\u0026gt;(); ","date":"2024-03-05T17:31:11+09:00","image":"https://sangho0n.github.io/en/p/unreal-smart-pointers/img/unreal.svg","permalink":"https://sangho0n.github.io/en/p/unreal-smart-pointers/","title":"Unreal Smart Pointers"},{"content":"When selecting a sorting algorithm, not only should you consider the time complexity in best, average, and worst conditions, but also factors such as memory usage and stability.\nThe speed of a comparison-based sorting algorithm in the worst case condition cannot be faster than O(nlog(n)).\nList of Sorting Algorithms in This Post Selection Sort Insertion Sort Bubble Sort Heap Sort Quick Sort Merge Sort Radix Sort Selection Sort One of the simplest algorithms. Suitable for environments where copying operations are slow due to being an in-place algorithm.\nIt scans the array once at each step, selects the minimum (or maximum) value among the unsorted elements and swaps it with the first element.\nAfter each step, it reduces the number of unsorted elements by 1 and repeats the same operation for the reduced array.\nIn-Place. Unstable.\nTime Complexity Case Complexity Best O(n2) Worst O(n2) Average O(n2) Insertion Sort Divides one array into a sorted and an unsorted array, increasing the size of the sorted array step by step and decreasing the size of the unsorted array.\nIt takes the front element of the unsorted array and compares it sequentially with the elements of the sorted array until it finds the right position to insert.\nIn-Place. Stable.\nTime Complexity Case Complexity Best (Already sorted) O(n) Worst O(n2) Average O(n2) Bubble Sort At each step, it linearly scans the array and performs comparisons and swaps with adjacent elements similar to bubbles rising in a cylinder.\nIn-Place. Stable.\nTime Complexity Case Complexity Best O(n2) Worst O(n2) Average O(n2) Heap Sort A method of sorting using a Max Heap or Min Heap. It is possible to use a separate heap or transform the given array into a heap (In-Place).\nThe operations of inserting/deleting elements in a heap are O(logn) (height of the heap, a complete binary tree), and performing these operations for the number of elements (twice; making the heap + removing one element from the heap) results in an overall time complexity of O(nlogn).\nIn-Place. Unstable.\nTime Complexity Case Complexity Best O(nlogn) Worst O(nlogn) Average O(nlogn) Quick Sort Divides the array into smaller arrays based on a pivot value, with smaller values on the left and larger values on the right.\nFor each divided array, Quick Sort is performed recursively until it cannot be divided further.\nIf the pivot is optimally selected at each moment, the given array is precisely halved each time. The worst case is when the pivot is always selected as the minimum value (or maximum value).\nIn-Place. Unstable.\nTime Complexity Case Complexity Best O(nlogn) Worst O(n2) Average O(nlogn) Merge Sort One of the divide-and-conquer algorithms. It divides the array in half and performs Merge Sort on each divided array. Then, it merges the sorted arrays together to obtain one large sorted array.\nUnlike other sorting algorithms, it has a space complexity of O(n) even in the best case.\nTo optimize the sorting of divided arrays, Merge Sort can be mixed with other sorting algorithms (such as Insertion Sort) based on a specific size (in this case, it may not be stable).\nNot In-Place. Stable.\nTime Complexity Case Complexity Best O(nlogn) Worst O(nlogn) Average O(nlogn) Radix Sort Unlike the previous algorithms, a sorting algorithm that performs without comparisons. It sorts based on digits, so the digits must be able to be sorted lexicographically.\nA type of bucket sort.\nNot In-Place. Stable\nTime Complexity Let n be the number of elements to be sorted, d be the maximum number of digits, and k be the number of buckets (for numbers, it is 10 as the digits are 0 to 9).\nBoth best, worst, and average cases have a complexity of O(d(n + k)).\n","date":"2024-02-26T11:49:35+09:00","image":"https://sangho0n.github.io/en/p/simple-summary-of-sorting-algorithms/img/algorithm_hu8666b0214ef6ef8b40207752073739fc_14421_120x120_fill_box_smart1_3.png","permalink":"https://sangho0n.github.io/en/p/simple-summary-of-sorting-algorithms/","title":"Simple Summary of Sorting Algorithms"},{"content":"\nStarting from Unreal Engine 5, the existing input mapping system has been deprecated. Let\u0026rsquo;s take a look at the Enhanced Input system that replaces it.\nIn order to efficiently support complex input processing and runtime control remapping, Enhanced Input was introduced with UE5. It is an upgraded version of the default input system in UE4, while also providing backward compatibility. This system allows for implementing features such as radial dead zones, compound actions, combo attacks, etc. in an asset-based environment.\nCore Concepts The Enhanced Input system has four key concepts:\nInput Action: Acts as a connection between the Enhanced Input system and project code. An input action can notify up to three independent floating-point values regardless of the input that triggered it.\nInput Mapping Context: Maps user input to input actions. It can be dynamically added or removed per user and can have priorities. By applying one or more input mapping contexts to a player and assigning priorities, conflicts can be resolved when multiple actions are triggered by the same input.\nExample: Opening a door button and a bag button being the same.\nOn the other hand, the following two concepts are elements that help make input processing more flexible.\nModifier: Used to refine input values. It can apply dead zones to prevent responses to slight movements or make input values smoother. Developers can use predefined modifiers or define their own. Trigger: Determines whether to activate the input action based on data processed by modifiers or the result of other input actions. Input Actions Play the role of connecting the Enhanced Input system with project code. To trigger an input action, the corresponding input action must be added to the input mapping context, and the input mapping context must be registered with the Enhanced Input Local Player Subsystem of the local player.\nTo make a Pawn respond to the triggered input action, you must control it using Blueprints or C++.\nInput Mapping Contexts In an input mapping context, inputs can be mapped to input actions. Once mappings are complete, the mapped context can be added or removed from the Enhanced Input Local Player Subsystem of the local player at any time.\nModifier Modifiers are preprocessors that allow you to adjust input values before sending them through triggers. Unreal Engine provides the following modifiers by default.\nDirectional Input As an example of using modifiers effectively, consider 2D directional input using a single input action. When creating a third-person template project, looking at IA_Move and IMC_Default, you can see how they are set as shown below:\nKey Direction Scalar Value Modifier Desired Direction Vector w Up 1 Swizzle Input Axis Value (1, 0, 0) s Down 1 Swizzle Input Axis Value, Negate (-1, 0, 0) a Left 1 Negate (0, -1, 0) d Right 1 - (0, 1, 0) Looking at the declaration and part of the implementation of UInputModifierSwizzleAxis, you can see the following:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 UCLASS(NotBlueprintable, MinimalAPI, meta = (DisplayName = \u0026#34;Swizzle Input Axis Values\u0026#34;)) class UInputModifierSwizzleAxis : public UInputModifier { GENERATED_BODY() public: UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Settings) EInputAxisSwizzle Order = EInputAxisSwizzle::YXZ; protected: virtual FInputActionValue ModifyRaw_Implementation(const UEnhancedPlayerInput* PlayerInput, FInputActionValue CurrentValue, float DeltaTime) override; virtual FLinearColor GetVisualizationColor_Implementation(FInputActionValue SampleValue, FInputActionValue FinalValue) const override; }; FInputActionValue UInputModifierSwizzleAxis::ModifyRaw_Implementation(const UEnhancedPlayerInput* PlayerInput, FInputActionValue CurrentValue, float DeltaTime) { FVector Value = CurrentValue.Get\u0026lt;FVector\u0026gt;(); switch (Order) { case EInputAxisSwizzle::YXZ: Swap(Value.X, Value.Y); break; case EInputAxisSwizzle::ZYX: Swap(Value.X, Value.Z); break; case EInputAxisSwizzle::XZY: Swap(Value.Y, Value.Z); break; case EInputAxisSwizzle::YZX: Value = FVector(Value.Y, Value.Z, Value.X); break; case EInputAxisSwizzle::ZXY: Value = FVector(Value.Z, Value.X, Value.Y); break; } return FInputActionValue(CurrentValue.GetValueType(), Value); } With the Order defaulting to YXZ, passing a scalar value of 1 through the modifier results in a value of (1.0f, 0.0f, 0.0f). Setting the modifier as described in the table above allows you to convert scalar values into the desired direction vectors.\nTrigger A trigger examines values that have passed through a list of modifiers and determines whether the value can activate an action. However, the Chorded Action trigger is an exception as it is triggered through a different input action. Below is a list of the basic triggers.\nThe trigger types include Explicit, Implicit, and Blocker:\nExplicit: Input is successful when the trigger succeeds. Implicit: Input is successful if the trigger succeeds and all implicit trigger types succeed. Blocker: Input fails when the trigger succeeds. The table below illustrates the types based on trigger classes:\nTrigger Class (cpp) Type UInputTrigger (default) ETriggerType::Explicit UInputTriggerCombo ETriggerType::Implicit UInputTriggerChordAction ETriggerType::Implicit UInputTriggerChordBlocker ETriggerType::Blocker After processing user input, a trigger can return one of three states:\nNone: The condition is not met, so the trigger fails. Ongoing: The condition is partially met, and the trigger is in progress but has not succeeded yet. Triggered: All input trigger conditions are met, and the input trigger is successful. By inheriting from the InputTrigger class or the InputTriggerTimedBase class, you can create custom triggers. The InputTriggerTimedBase class checks whether input has persisted for a certain duration and returns Ongoing while the input persists. However, InputTriggerTimedBase defaults to not return Triggered even if the condition is met. So, if you have created a new trigger by inheriting this class, you need to override the GetTriggerType and UpdateState methods to return the desired states.\n","date":"2024-02-14T17:44:19+09:00","image":"https://sangho0n.github.io/en/p/unreal-enhanced-input/img/unreal.svg","permalink":"https://sangho0n.github.io/en/p/unreal-enhanced-input/","title":"Unreal Enhanced Input"},{"content":"Based on the lecture by Lee Deuk-woo and documentation compiled by another developer.\nFor detailed and accurate information, please refer to the links above.\nSeries:\nOverview of Unreal GAS \u0026lt;- Current post Getting started with Unreal GAS Gameplay Ability System A framework that provides actor abilities and interactions between actors through abilities Advantages Flexibility, scalability: Easily utilized for various and complex game development Modular system: Minimizes dependencies for each function Network support Data-driven design Completeness: Games like Fortnite already utilize this system Disadvantages Learning cost Overhead in small projects Suitable for creating large-scale RPGs and multiplayer games\nComponents Gameplay Ability: Implementation of character abilities based on cost and cooldown (optional) Attributes: Manipulation of actor characteristics Gameplay Effects: Changes in actor state based on ability activation Gameplay Tags: Tagging actors Gameplay Cues: Visual effects Replication for all of the above GAS in Multiplayer Games The GAS plugin supports client-side prediction, allowing ability activation and effects without server permission.\nAbility activation Animation montages playback Attribute changes Tagging for gameplay Execution of gameplay cues Movement manipulation through RootMotionSource functions associated with CharacterMovementComponent Blueprint vs C++ GAS should be implemented using C++, but it is possible to implement GameplayAbilities and GameplayEffects using Blueprint.\n","date":"2024-02-14T13:53:44+09:00","image":"https://sangho0n.github.io/en/p/overview-of-unreal-gas/img/unreal.svg","permalink":"https://sangho0n.github.io/en/p/overview-of-unreal-gas/","title":"Overview of Unreal GAS"}]