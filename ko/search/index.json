[{"content":"이득우 님의 강의 와 다른 개발자가 정리해놓은 문서를 보고 정리한 내용입니다.\n자세하고 정확한 내용은 위 링크를 참조하세요\n시리즈\n언리얼 GAS 개요 언리얼 GAS 시작 \u0026lt;- 현재포스트 이번 포스트에서는 아래 3가지의 방법을 통해 액터의 움직임을 구현해보면서 GAS 프레임워크의 사용 방식에 대해 알아보고, 각 방식에 따른 차이점을 살펴보겠다.\n액터 기능 확장 Game Ability System 사용 Game Ability System + Gameplay Tag 사용 액터로는 분수대, 움직임은 3초간 제자리 회전/정지를 기준으로 제작하였다.\n액터 기능 확장 GAS 프레임워크 없이 URotatingMovementComponent을 직접 사용하여 구현\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 UCLASS() class ARENABATTLEGAS_API AABGASFountain : public AABFountain { GENERATED_BODY() public: AABGASFountain(); protected: virtual void PostInitializeComponents() override; virtual void BeginPlay() override; virtual void TimerAction(); protected: UPROPERTY(VisibleAnywhere, Category=Movement) TObjectPtr\u0026lt;URotatingMovementComponent\u0026gt; RotatingMovement; UPROPERTY(EditAnywhere, Category=Timer) float ActionInterval; FTimerHandle ActionTimer; }; void AABGASFountain::BeginPlay() { Super::BeginPlay(); GetWorld()-\u0026gt;GetTimerManager().SetTimer(ActionTimer, this, \u0026amp;AABGASFountain::TimerAction, ActionInterval, true, 0.0f); } void AABGASFountain::TimerAction() { if(!RotatingMovement-\u0026gt;IsActive()) { RotatingMovement-\u0026gt;Activate(); } else { RotatingMovement-\u0026gt;Deactivate(); } } Game Ability System 사용 GAS 프레임워크를 이용하여 움직임을 구현하기 위해서는, 아래 두 개념을 먼저 이해해야 한다.\nAbility System Component Game Ability Ability System Component 게임플레이 어빌리티 시스템을 관리하는 컴포넌트 액터 당 하나만 부착 가능 액터는 이를 통하여 Gameplay Ability를 발동시킬 수 있음 해당 컴포넌트를 부착한 액터 사이에 Game Ability System에 의한 상호작용이 가능해짐 Game Ability Ability System Component에 등록되어 발동시킬 수 있는 액션 발동 과정 Ability System Component에 등록 : AbilitySystemComponent-\u0026gt;GiveAbility() 액션 발동 : AbilitySystemComponent-\u0026gt;TryActivateAbility() 발동된 ability 내부에서는 SpecHandle, ActorInfo, ActivationInfo를 활용하여 요구사항 구현 주요 메서드 CanActivateAbility ActivateAbility CancelAbility EndAbility 위 두 개념을 이용하여 맨 처음과 동일한 움직임을 구현하면 아래와 같다.\nGameplayAbility를 상속하여 어빌리티 클래스 생성 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 UCLASS() class ARENABATTLEGAS_API UABGA_Rotate : public UGameplayAbility { GENERATED_BODY() virtual void ActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, const FGameplayEventData* TriggerEventData) override; virtual void CancelAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, bool bReplicateCancelAbility) override; }; void UABGA_Rotate::ActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, const FGameplayEventData* TriggerEventData) { Super::ActivateAbility(Handle, ActorInfo, ActivationInfo, TriggerEventData); if(auto Avatar = ActorInfo-\u0026gt;AvatarActor.Get()) { if(auto RotatingMovement = Avatar-\u0026gt;GetComponentByClass(URotatingMovementComponent::StaticClass())) { RotatingMovement-\u0026gt;Activate(); } } } void UABGA_Rotate::CancelAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, bool bReplicateCancelAbility) { Super::CancelAbility(Handle, ActorInfo, ActivationInfo, bReplicateCancelAbility); // 생략 } 액터에 컴포넌트 부착 및 인터페이스 구현 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 UCLASS() class ARENABATTLEGAS_API AABGASFountain : public AABFountain, public IAbilitySystemInterface { GENERATED_BODY() public: AABGASFountain(); virtual UAbilitySystemComponent* GetAbilitySystemComponent() const override; // pure virtual //... UPROPERTY(VisibleAnywhere, Category=Ability) TObjectPtr\u0026lt;UAbilitySystemComponent\u0026gt; AbilitySystemComponent; UPROPERTY(VisibleAnywhere, Category=Ability) TObjectPtr\u0026lt;URotatingMovementComponent\u0026gt; RotatingMovement; UPROPERTY(EditAnywhere, Category=Timer) float ActionInterval; FTimerHandle ActionTimer; }; UAbilitySystemComponent* AABGASFountain::GetAbilitySystemComponent() const { return AbilitySystemComponent; } 부착된 컴포넌트에 어빌리티 등록 및 발동 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 void AABGASFountain::PostInitializeComponents() { Super::PostInitializeComponents(); AbilitySystemComponent-\u0026gt;InitAbilityActorInfo(this, this); FGameplayAbilitySpec RotateSpec(UABGA_Rotate::StaticClass()); AbilitySystemComponent-\u0026gt;GiveAbility(RotateSpec); } void AABGASFountain::TimerAction() { if(auto RotateSpec = AbilitySystemComponent-\u0026gt;FindAbilitySpecFromClass(UABGA_Rotate::StaticClass())) { if(!RotateSpec-\u0026gt;IsActive()) { AbilitySystemComponent-\u0026gt;TryActivateAbility(RotateSpec-\u0026gt;Handle); } else { AbilitySystemComponent-\u0026gt;CancelAbilityHandle(RotateSpec-\u0026gt;Handle); } } } Game Ability System + Gameplay Tag 사용 게임플레이 태그 없이 Game Ability System만을 사용하여 구현하는 경우, GAS 프레임워크의 장점을 최대로 활용할 수 없다. Gameplay Tag가 무엇인지 먼저 알아보자\nGameplay Tags FGameplayTag란 Parent.Child.Grandchild...와 같이 계층적 형태로 등록/관리되는 이름을 의미한다. GameplayTagManager에 의해 등록된다. 이러한 태그들을 이용하여 클래스들을 분류하고, 상태를 효과적으로 추적할 수 있다.\n상태 추적을 위해 bool값이나 enum을 두고 해당 값을 기준으로 조건문을 통해 상태를 확인하던 방식들은, 해당 오브젝트가 Gameplay Tag를 가지고있는지 여부로 대체할 수 있다.\n한편 여러개의 Tag들은 Tarray보다는 FGameplayTagContainer를 이용하여 관리하는 것이 좋다. 언제든 배열 형태로 태그들을 받아볼 수 있을 뿐만 아니라, 여러 메서드를 통해 태그 관리를 쉽게 할 수 있기 때문이다.\nGAS 프레임워크는 Gameplay Tag와 매우 친화적이다. UAbilitySystemComponent가 IGameplayTagAssetInterface를 구현하기 때문에 Ability System Component에 직접 태그를 지정할 수 있을 뿐만 아니라, 아래와 같이 GameplayAbility의 여러 상태들을 태그 컨테이너로 관리할 수 있도록 구현해두었기 때문이다.\n1 2 3 4 5 6 7 8 9 10 11 12 // GameplayAbility.h /** Abilities with these tags are cancelled when this ability is executed */ UPROPERTY(EditDefaultsOnly, Category = Tags, meta=(Categories=\u0026#34;AbilityTagCategory\u0026#34;)) FGameplayTagContainer CancelAbilitiesWithTag; /** Abilities with these tags are blocked while this ability is active */ UPROPERTY(EditDefaultsOnly, Category = Tags, meta=(Categories=\u0026#34;AbilityTagCategory\u0026#34;)) FGameplayTagContainer BlockAbilitiesWithTag; /** Tags to apply to activating owner while this ability is active. These are replicated if ReplicateActivationOwnedTags is enabled in AbilitySystemGlobals. */ UPROPERTY(EditDefaultsOnly, Category = Tags, meta=(Categories=\u0026#34;OwnedTagsCategory\u0026#34;)) FGameplayTagContainer ActivationOwnedTags; 또한 게임플레이 태그를 활용하면, 액터 클래스에서 Gameplay Ability 클래스에 대한 정보가 없어도 동일한 요구사항을 구현할 수 있기 때문에 코드 간 낮은 의존성을 유지시킬 수 있다는 장점이 있다.\n게임플레이 태그를 활용하면 동일한 요구 사항을 아래와 같이 구현할 수 있다.\n태그 생성 1 2 3 4 5 // DefaultGameplayTags.ini [/Script/GameplayTags.GameplayTagsSettings] //... +GameplayTagList=(Tag=\u0026#34;Actor.Action.Rotate\u0026#34;,DevComment=\u0026#34;\u0026#34;) +GameplayTagList=(Tag=\u0026#34;Actor.State.IsRotating\u0026#34;,DevComment=\u0026#34;\u0026#34;) 태그를 쉽게 얻어오기 위한 매크로 작성 1 2 3 // ABGameplayTag.h #define ABTAG_ACTOR_ROTATE FGameplayTag::RequestGameplayTag(FName(\u0026#34;Actor.Action.Rotate\u0026#34;)) #define ABTAG_ACTOR_ISROTATING FGameplayTag::RequestGameplayTag(FName(\u0026#34;Actor.State.IsRotating\u0026#34;)) Gameplay Ability에 태그 등록 1 2 3 4 5 6 UABGA_Rotate::UABGA_Rotate() { AbilityTags.AddTag(ABTAG_ACTOR_ROTATE); // 활성화될 때 아래 태그가 심어짐 ActivationOwnedTags.AddTag(ABTAG_ACTOR_ISROTATING); } 태그를 활용한 어빌리티 등록 및 활성화 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // ABGASFountain.h UPROPERTY(EditAnywhere, Category=GAS) TArray\u0026lt;TSubclassOf\u0026lt;UGameplayAbility\u0026gt;\u0026gt; Abilities; // 구현부 void AABGASFountain::PostInitializeComponents() { Super::PostInitializeComponents(); AbilitySystemComponent-\u0026gt;InitAbilityActorInfo(this, this); for (auto Element : Abilities) { FGameplayAbilitySpec Spec(Element); AbilitySystemComponent-\u0026gt;GiveAbility(Spec); } } void AABGASFountain::TimerAction() { FGameplayTagContainer TargetTag(ABTAG_ACTOR_ROTATE); if(!AbilitySystemComponent-\u0026gt;HasMatchingGameplayTag(ABTAG_ACTOR_ISROTATING)) { AbilitySystemComponent-\u0026gt;TryActivateAbilitiesByTag(TargetTag); } else { AbilitySystemComponent-\u0026gt;CancelAbilities(\u0026amp;TargetTag); } } 이후 AABGASFountain cpp 클래스를 상속하는 블루프린트 클래스를 만든 후, Details 패널에서 알맞은 액티비티를 Abilities에 넣어주면 된다.\n정리 회전하는 분수대를 세 가지의 방법으로 구현\n액터의 기능 확장 GAS : 새로운 클래스(ability)를 만들어 액터로부터 기능 분리 GAS + Gameplay Tags : 태그를 활용해 액터와 ability 간 의존성 제거 GAS와 Gameplay Tags를 같이 사용했을 때의 좋은 점\n액터의 역할 최소화 의존성 제거. 유지보수가 쉬워지고, 재사용성이 높아짐 확장성 + 타직군 과의 협업 용이 ","date":"2024-03-18T15:58:25+09:00","image":"https://sangho0n.github.io/ko/p/%EC%96%B8%EB%A6%AC%EC%96%BC-gas-%EC%8B%9C%EC%9E%91/img/unreal.svg","permalink":"https://sangho0n.github.io/ko/p/%EC%96%B8%EB%A6%AC%EC%96%BC-gas-%EC%8B%9C%EC%9E%91/","title":"언리얼 GAS 시작"},{"content":"다른 언어를 쓰면서 희미해졌던 기억을 되살리기 위한 글. 이번 포스트에서는 c++에서의 상속관계 및 virtual 키워드에 대해 자세히 알아보도록 하겠다.\n상속 c++은 java와 c#등과 같은 다른 객체지향 언어와 달리 상속 시 접근 제한자를 지정할 수 있다.\n1 2 // syntax clsss Derived : \u0026lt;access_specifier\u0026gt; Parent 이는 부모클래스를 상속할 때, 부모클래스의 원소를 어떻게 받을 것인지를 나타낸다. access_specifier에 명시된 유형보다 느슨하게 지정된 원소들을 해당 유형으로 바꿔 상속받는다 생각하면 된다.\n아래의 클래스를 상속하는 3가지 유형의 클래스를 살펴보며 각각 어떤 특징을 갖는지 살펴볼 것이다.\n1 2 3 4 5 6 7 8 9 class Base { public: int pubInt = 1; private: int privInt = 2; protected: int protInt = 3; }; public is-a 관계를 나타낼 때 사용. 부모의 접근지정자를 그대로 따른다.\n1 2 3 4 5 6 7 8 9 10 class Pub : public Base // is-a { public: Pub() { pubInt = 1; // public //privInt = 2; // 부모클래스의 private이기 때문에 접근할 수 없음 protInt = 3; // protected } }; 따라서 외부에서는 부모클래스에서 public으로 지정된 pubInt에만 접근할 수 있다.\n1 2 3 4 Pub* pub = new Pub(); cout \u0026lt;\u0026lt; pub-\u0026gt;pubInt \u0026lt;\u0026lt; endl; //cout \u0026lt;\u0026lt; pub-\u0026gt;privInt \u0026lt;\u0026lt; endl; //error: ‘int Base::privInt’ is private within this context //cout \u0026lt;\u0026lt; pub-\u0026gt;protInt \u0026lt;\u0026lt; endl; //error: ‘int Base::protInt’ is protected within this context private is-implemented-in-terms-of 관계를 나타낼 때 사용(default in cpp). 부모 클래스의 원소 중 private보다 느슨하게 접근할 수 있는 원소(protected와 public으로 지정된 원소)를 private으로 상속한다.\n1 2 3 4 5 6 7 8 9 10 class Priv : private Base // is-implemented-in-terms-of(cover this later) { public: Priv() { pubInt = 1; // public -\u0026gt; private //privInt = 2; // 부모클래스의 private이기 때문에 접근할 수 없음 protInt = 3; // protected- \u0026gt; private } }; 따라서 외부에서는 부모클래스의 어떤 원소에도 접근할 수 없다.\n1 2 3 4 Priv* priv = new Priv(); //cout \u0026lt;\u0026lt; priv-\u0026gt;pubInt \u0026lt;\u0026lt; endl; //error: ‘int Base::pubInt’ is inaccessible within this context //cout \u0026lt;\u0026lt; priv-\u0026gt;privInt \u0026lt;\u0026lt; endl; //error: ‘int Base::privInt’ is private within this context //cout \u0026lt;\u0026lt; priv-\u0026gt;protInt \u0026lt;\u0026lt; endl; //error: ‘int Base::protInt’ is protected within this context 또한 이 클래스를 상속받는 새로운 클래스를 만들어도 조부모클래스의 어떤 원소에도 접근할 수 없다.\n1 2 3 4 5 6 7 8 class GrandChild : Priv { public: GrandChild() { // Base의 어떤 원소에도 접근 불가능 } }; protected private 지정자와 마찬가지로 is-implemented-in-terms-of 관계를 나타낼 때 사용. 부모클래스의 public원소를 protected로 변경하여 상속한다.\n1 2 3 4 5 6 7 8 9 10 class Prot : protected Base // is-implemented-in-terms-of { public: Prot() { pubInt = 1; // public -\u0026gt; protected //privInt = 2; // error: ‘int Base::privInt’ is private within this context protInt = 3;// protected } }; 따라서 외부에서는 Base클래스의 어떤 원소에도 접근할 수 없다.\n1 2 3 4 Prot* prot = new Prot(); //cout \u0026lt;\u0026lt; prot-\u0026gt;pubInt \u0026lt;\u0026lt; endl; //error: ‘int Base::pubInt’ is inaccessible within this context //cout \u0026lt;\u0026lt; prot-\u0026gt;privInt \u0026lt;\u0026lt; endl; //error: ‘int Base::privInt’ is private within this context //cout \u0026lt;\u0026lt; prot-\u0026gt;protInt \u0026lt;\u0026lt; endl; // error: ‘int Base::protInt’ is protected within this context 또한 private과 달리 이를 상속받는 클래스를 작성했을 때에는 조부모클래스의 원소에 접근할 수 있다.\n1 2 3 4 5 6 7 8 9 class GrandChild2 : Prot { public: GrandChild2() { pubInt = 1; // because it is specified protected protInt = 3; // because it is specified protected } }; 다만 위 코드에서는 default(private)으로 상속하였기 때문에, 외부에서는 GrandChild2의 pubInt와 protInt에 접근할 수 없다.\ncasting 각각의 경우에 대한 캐스팅 지원 여부는 아래와 같다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int main() { // upcasting check Base *ptr1, *ptr2, *ptr3; ptr1 = new Pub(); //ptr2 = new Priv(); // error: ‘Base’ is an inaccessible base of ‘Priv’ //ptr3 = new Prot(); // error: ‘Base’ is an inaccessible base of ‘Prot’ // downcasting check Base* base = new Base(); Pub* pub_down = static_cast\u0026lt;Pub*\u0026gt;(base); // compile-time에 검사. 다형성 여부 신경 쓰지 않음 // Pub* pub_down = dynamic_cast\u0026lt;Pub*\u0026gt;(base); // 가상함수가 없기 때문에 (source type is not polymorphic) 오류 // Priv* priv_down = static_cast\u0026lt;Priv*\u0026gt;(base); // error: ‘Base’ is an inaccessible base of ‘Priv’ // Prot* prot_down = static_cast\u0026lt;Prot*\u0026gt;(base); // error: ‘Base’ is an inaccessible base of ‘Prot’ delete ptr1, ptr2, ptr3, pub_down, base; return 0; } 한편, 다른 언어에 익숙한 사람이거나 개발하면서 상속에서의 접근지정자에 대해 크게 고민해본 적이 없는 사람이라면 도대체 is-implemented-in-terms-of이 뭐길래 non-public 상속으로 이를 나타내는지 궁금해할 것이다.\nis-implemented-in-terms-of 일반적인 프로그래밍 언어에서는 is-a관계는 상속(cpp의 경우 public 상속)을, has-a관계는 composition(;containment, aggregation)을 이용해 객체 간의 관계를 나타낸다. cpp은 위 두 개념과 더불어 is-implemented-in-terms-of라는 용어를 사용하여 객체 관의 관계를 나타낸다.\n이름에서도 알 수 있듯, is-implemented-in-terms-of는 어떤 객체가 다른 객체를 사용하여 동작할 때를 의미한다. 따라서 is-implemented-in-terms-of 역시 cpp에서는 composition을 이용해 나타낼 수 있다. 그렇다면 has-a와 is-implemented-in-terms-of의 차이가 무엇일까? 두 관계를 나누는 기준은 바로 domain이다.\nhas-a관계는 우리가 일상속에서 쉽게 인지할 수 있는 영역을 프로그래밍으로 모델링할 때 사용된다. 예를 들어 사람, 통신수단, 운송수단과 같은 어플리케이션 도메인을 has-a 관계로 모델링할 수 있다. 반면 is-implemented-in-terms-of는 온전히 소프트웨어 구현의 영역을 나타낼 때를 지칭힌다. 버퍼, 뮤텍스, 탐색트리 등을 예시로 들 수 있다.\ncpp에서의 has-a 관계는 다른 언어와 마찬가지로 컴포지션으로 구현할 수 있다. 한편 is-implemented-in-terms-of 관계는 has-a와 같은 방식으로 구현하거나, non-public 상속을 통해 구현할 수 있다.\n그렇다면 어떨 때 non-public 상속으로 구현하고, 어떨 때 composition으로 구현하는 게 적절할까? 두 방식으로 구현된 클래스를 보며 어떤 방식으로 구현하는 것이 좋을지 살펴보도록 하자.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 template \u0026lt;class T\u0026gt; class MyList { public: bool Insert( const T\u0026amp;, size_t index ); T Access( size_t index ) const; size_t Size() const; private: T* buf_; size_t bufsize_; }; template \u0026lt;class T\u0026gt; class MySet1 : private MyList\u0026lt;T\u0026gt; { public: bool Add( const T\u0026amp; ); // calls Insert() T Get( size_t index ) const; // calls Access() using MyList\u0026lt;T\u0026gt;::Size; //... }; template \u0026lt;class T\u0026gt; class MySet2 { public: bool Add( const T\u0026amp; ); // calls impl_.Insert() T Get( size_t index ) const; // calls impl_.Access() size_t Size() const; // calls impl_.Size(); //... private: MyList\u0026lt;T\u0026gt; impl_; }; 상속으로 구현 vs 컴포지션으로 구현 앞선 예시 코드를 통해서 확인할 수 있듯, 단일 컴포지션으로 할 수 있는 것은 모두 상속으로도 구현이 가능하다. 그렇다면 왜 is-implemented-in-terms-of와 has-a를 cpp은 구분하는 것일까?\n바로 non public 상속으로는 구현할 수 있는 것을 단일 컴포지션으로는 구현할 수 없는 경우가 있기 때문이다. 아래 5가지 항목은 각각의 경우를 말해준다(대략 자주 발생하는 경우부터 나열되었다).\nprotected 멤버에 접근할 필요가 있는 경우. 보통 protected 메서드(혹은 생성자)를 호출할 필요가 있는 경우를 뜻한다. 가상함수를 오버라이딩할 필요가 있는 경우. base 클래스에 pure virtual function이 있는 경우에는 컴포지션을 사용할 수 없다. 구현체를 또다른 구현체의 생성 이전에 생성(혹은 파괴 이후 파괴)해야 하는 경우. 여러 구현체가 서로 종속되어 있어, 특정 구현체의 생애가 조금 더 길어야하는 경우를 말한다. 구현체에 critical section이나 data transaction과 같이 lock이 필요한 경우엔 다른 구현체의 lifetime을 전부 다 cover할 수 있어야 한다. 가상 기본 클래스(virtual base class)를 공유하거나, 가상 기본 클래스 생성에 대한 변경이 필요한 경우. 마지막으로, is-implemented-in-terms-of과는 거리가 있지만, 컴포지션으로는 구현할 수 없는 non public 상속만의 특징이 하나 더 있다.\n\u0026lsquo;제한된 다형성\u0026rsquo;이 필요한 경우; 일부 코드에 대해서만 리스코프 치환이 필요한 경우. public 상속은 \u0026lsquo;항상\u0026rsquo; 리스코프 치환 가능하다. 반면 non public 상속은 \u0026lsquo;제한된\u0026rsquo; IS-A관계를 나타낼 수 있다. 물론 클래스 외부에서는 non public 상속으로는 전혀 다형적이지 않게 느껴지지만 (Derived 클래스는 Base클래스가 아니지만; D is not a B), 멤버함수 내부에서 혹은 freind 클래스에서는 다형성이 필요한 경우가 있을 수 있다. 다시 MySet과 MyList 코드를 살펴보도록 하자. 이 경우에는\nMyList는 protected 멤버가 없다. MyList는 추상 클래스가 아니다. MySet은 MyList 이외에 다른 클래스를 상속받지 않는다. MyList는 MySet이 필요로하거나 생성을 재정의할 가상 기본 클래스를 상속하지 않는다. MySet은 MyList가 아니다; MySet is-not-a MyList 다섯가지 상황에 모두 해당되지 않으므로 상속보다는 컴포지션으로 구현하는 것이 좋다. 상속의 경우 쓸데없는 정보까지 자식클래스에서 확인할 수 있기도 하고, 필요 이상의 종속성이 생기기 때문이다.\n정리하면서 느낀 건데, c++은 다른 언어에 비해 객체 관계를 구현하는 방법이 참 많은 것 같다. 동시에 이해하기도 쉽지 않을 뿐더러, 객체지향의 원칙에 위배되기에 함부로 남발하면 안되는 부분도 참 많은 것 같다.\n오죽하면 언리얼에서도 public 상속을 강제할까\n다형성 다형성이란 같은 이름의 연산자 혹은 메서드가 다른 역할을 수행할 수 있는 것을 말한다. cpp에서의 다형성은 연산자/메서드 오버로딩과, 메서드 오버라이딩을 통해 구현할 수 있다. 이 중 메서드 오버라이딩은 virtual 키워드와 함께 사용된다. 이번 포스트에서는 메서드 오버라이딩과 함께 사용되는 virtual키워드가 어떻게 사용되는지 알아보겠다.\nvirtual cpp에서 virtual 키워드는 가상함수를 선언할 때와, 가상 기반 클래스(virtual base class)를 상속할 때 사용된다.\n1 2 3 4 5 // syntax virtual [type-specifiers] member_function_declarator class Class_Name : virtual [access-specifier] Base_Class_Name class Class_Name : [access-specifier] virtual Base_Class_Name virtual function 가상함수는 다형성을 위해 자식 클래스에서 override하기 위한 함수를 선언할 때 사용된다. 가상함수로 선언된 함수는 컴파일러에 의해 클래스마다 생성된 vTable(virtual table)에 등록되며, 런타임에 이에 접근(vPtr)하여 어떤 함수를 호출할지 결정한다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 // C++ program to show the working of vtable and vptr #include \u0026lt;iostream\u0026gt; using namespace std; // base class class Base { public: virtual void function1() { cout \u0026lt;\u0026lt; \u0026#34;Base function1()\u0026#34; \u0026lt;\u0026lt; endl; } virtual void function2() { cout \u0026lt;\u0026lt; \u0026#34;Base function2()\u0026#34; \u0026lt;\u0026lt; endl; } virtual void function3() { cout \u0026lt;\u0026lt; \u0026#34;Base function3()\u0026#34; \u0026lt;\u0026lt; endl; } }; // class derived from Base class Derived1 : public Base { public: // overriding function1() void function1() { cout \u0026lt;\u0026lt; \u0026#34;Derived1 function1()\u0026#34; \u0026lt;\u0026lt; endl; } // not overriding function2() and function3() }; // class derived from Derived1 class Derived2 : public Derived1 { public: // again overriding function2() void function2() { cout \u0026lt;\u0026lt; \u0026#34;Derived2 function2()\u0026#34; \u0026lt;\u0026lt; endl; } // not overriding function1() and function3() }; // driver code int main() { // defining base class pointers Base* ptr1 = new Base(); Base* ptr2 = new Derived1(); Base* ptr3 = new Derived2(); // calling all functions ptr1-\u0026gt;function1(); ptr1-\u0026gt;function2(); ptr1-\u0026gt;function3(); ptr2-\u0026gt;function1(); ptr2-\u0026gt;function2(); ptr2-\u0026gt;function3(); ptr3-\u0026gt;function1(); ptr3-\u0026gt;function2(); ptr3-\u0026gt;function3(); // deleting objects delete ptr1; delete ptr2; delete ptr3; return 0; } // Console Output Base function1() Base function2() Base function3() Derived1 function1() Base function2() Base function3() Derived1 function1() Derived2 function2() Base function3() virtual base class cpp은 다중상속을 허용한다. 한편 인스턴스 생성 시 주소공간에 부모가 먼저 생성된 후, 자식의 생성자가 호출된다. 그렇다면 어떤 클래스가 다른 부모, 같은 조부모를 두었다고 했을 때는 어떤 일이 벌어질까?\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;iostream\u0026gt; using namespace std; class A { public: void show() { cout \u0026lt;\u0026lt; \u0026#34;Hello form A \\n\u0026#34;; } }; class B : public A { }; class C : public A { }; class D : public B, public C { }; int main() { D object; object.show(); } 위와 같은 상황에서는 메모리에 A 영역이 2번 올라가려고 할 것이다. 다행이도 컴파일러는 이를 검출해내어 오류를 방출한다. 사실 위와 같은 상속구조는 데스 다이아몬드 문제를 야기할 수 있기 때문에, 권장되는 상속구조는 아니다.\n그럼에도 불구하고 A의 show()를 호출하고 싶을 때는 B와 C가 A를 가상 기본으로 상속받게하면 된다.\n1 2 3 4 5 6 class B : virtual public A { }; class C : public virtual A { }; // 둘 다 가능한 문법 References \u0026ldquo;Effective C++” Third Edition by Scott Meyers. Uses and Abuses of Inheritance What is the difference between public, private, and protected inheritance? virtual (C++) C++ Polymorphism vTable And vPtr in C++ Virtual base class in C++ ","date":"2024-03-08T11:12:45+09:00","image":"https://sangho0n.github.io/ko/p/c-%EC%83%81%EC%86%8D%EA%B3%BC-virtual-%ED%82%A4%EC%9B%8C%EB%93%9C/img/cpp.svg","permalink":"https://sangho0n.github.io/ko/p/c-%EC%83%81%EC%86%8D%EA%B3%BC-virtual-%ED%82%A4%EC%9B%8C%EB%93%9C/","title":"C++ 상속과 virtual 키워드"},{"content":"공식문서를 바탕으로 이해한 내용을 작성한 글입니다. (의역 多) 실제와는 다른 내용이 있을 수 있습니다. 지적해주시면 감사하겠습니다.\n언리얼은 cpp 사용되는 여러 스마트 포인터들에 대한 구현체를 제공한다. 제공되는 클래스로는 Shared 포인터와 Weak포인터, Unique 포인터는 물론 여기에다가 Shared Reference라는 특이한 타입이 하나가 추가되었다. UObject는 별도의 메모리 트래킹 시스템에 의해 관리되기 때문에, UObject를 상속받는 클래스의 인스턴스는 스마트포인터로 감쌀 수 없다. (가비지 컬렉션과는 다른 방식으로 메모리를 회수하는 구조; RAII 패턴)\n타입 종류 타입명 사용처 TSharedPtr 쉐어드 포인터는 감싸고 있는 객체를 소유하는 클래스이다. 소유하고 있는 동안 객체가 외부에 의해 소멸되지 못하게 막으며, 궁극적으로는 해당 객체를 소유하고 있는 쉐어드 포인터(혹은 레퍼런스)의 개수가 0이 될 때 객체의 소멸을 관장한다. 쉐어드포인터는 감싸고 있는 객체가 없는 상태로도 존재할 수 있다. 감싸고 있는 객체가 null이 아닐 때 언제든 쉐어드 레퍼런스를 생성할 수 있다. TSharedRef 쉐어드 포인터와 유사하게 동작하지만, 감싸고 있는 객체가 null이 될 수 없다는 점에서 다르다. null이 불가능하기 때문에 언제든 쉐어드 포인터로 변환될 수 있으며, 이때 가리키고 있는 객체는 항상 유효한 상태이다. 객체의 소유권을 명확히하고 싶을 때나 객체가 null이 아님을 보장하고 싶을 때 사용된다. TWeakPtr 쉐어드 포인터와 유사하지만, 객체를 소유하고 있지 않기 때문에 라이프사이클에 영향을 주지 않는다. 이러한 특징 때문에 1)참조사이클을 끊는 데 유용하게 사용할 수 있지만, 동시에 참조하는 객체가 언제든 경고 없이 null이 될 수 있기에 안전한 접근을 보장하고 싶다면 TSharedPtr로 변환 후 사용하는 것이 좋다. TUniquePtr 유니크 포인터는 객체를 독점적으로 소유한다. 소유권을 넘겨줄 수는 있지만 공유하지는 못한다. 유니크 포인터를 복사하려는 모든 경우에 컴파일 에러가 난다. 스코프를 벗어나게 되면 자동으로 소유하고 있는 객체를 메모리에서 해제한다. 1) 두 개 이상의 객체가 서로를 참조하는 경우 발생하는 현상. 참조카운트가 0이 되지 않아 객체들이 해제되지 않고 메모리 누수가 발생할 수 있다.\n이점 이점 설명 메모리 누수 방지 객체를 자동으로 소멸시켜주기 때문에 메모리 누수를 방지할 수 있다. 약한 참조 순환 참조 문제를 해결하고, 댕글링 포인터 문제를 방지한다. 스레드 안전 보장(optional) 필요한 경우 스레드 안전을 보장하는 코드를 추가로 작성할 수 있다. (오버헤드 존재) 런타임 안전성 쉐어드 레퍼런스는 null이 될 수 없고 언제든 참조를 해제할 수 있기 때문에 런타임 안정성을 부여한다. 의도 전달 1)소유자와 관찰자를 쉽게 구분할 수 있다. 메모리 상의 이점 cpp의 포인터 변수의 크기의 2배만으로도 이 모든 기능을 수행한다(64비트 기준; 16바이트의 참조 제어자 포함). 단, 유니크포인터는 cpp의 포인터와 동일한 크기를 갖는다. 1) 소유자는 객체를 소유하고 수명주기를 관리한다. 쉐어드포인터와 유니크포인터를 통해 객체를 소유하며, 더이상 필요하지 않을 때 메모리에서 해제한다. 관찰자는 객체를 참조하고 있지만 소유하지는 않는다(위크포인터). 객체의 소유자가 해당 객체를 삭제하면 관찰자는 알아서 null이되어야 한다.\n헬퍼 클래스와 함수 헬퍼 설명 클래스 TSharedFromThis TSahredFromThis를 상속받게 하면 해당 클래스에 AsShared와 SharedThis 메서드가 추가된다. 이러한 메서드들은 객체에 대한 TSharedRef를 얻을 수 있게 도와준다. 함수 MakeShared와 MakeShareable MakeShared 함수는 일반적인 cpp 포인터에서 TSharedPtr를 생성해낸다. 이 함수는 새로운 객체 인스턴스와 참조 컨트롤러를 단일 메모리 블록에 할당한다. 객체가 public 생성자를 가지고있어야한다. MakeShareable 역시 cpp포인터에서 TSharedPtr를 생성하는 데 사용된다. 이 함수는 객체의 생성자가 private인 경우에도 작동한다. 따라서 본인이 생성하지 않은 객체의 소유권을 얻고싶을 때에도 사용할 수 있으며, 추가로 소멸자가 호출되었을 때 개발자가 원하는 로직을 부여할 수도 있다. 이러한 추가 기능 때문에 MakeShared에 비해 더 유연한 프로그래밍을 할 수 있지만, 동시에 오버헤드 또한 존재한다. StaticCastSharedRef와 StaticCastSharedPtr 정적 캐스팅을 지원 하는 유틸리티 함수(주로 다운캐스팅) ConstCastSharedRef와 ConstCastSharedPtr 각각의 레퍼런스와 포인터형 변수에 대해 const에서 mutalble 가능한 객체를 반환한다. MakeShareable을 사용하여 소멸자에 추가 로직을 부여하는 예시\n1 2 3 4 5 6 TSharedPtr\u0026lt;FOnlineSession\u0026gt; SharedPtr = MakeShareable(new FOnlineSession(), [](FOnlineSession* ObjToDelete)-\u0026gt; void { // 커스텀 소멸자 구현 ObjToDelete-\u0026gt;PerformAdditionalCleanup(); delete ObjToDelete; }); 세부 구현 언리얼의 스마트포인터 라이브러리는 기능성과 효율성 모두 살린 채 구현되었다.\n속도 스마트포인터는 자원 관리 및 툴 프로그래밍과 같은 high-level 시스템에서는 매우 유용하게 사용되지만, cpp의 기본 포인터에 비해 느리게 동작하기에 렌더링 같은 low-level 엔진 코드에는 적합하지 않다.\n언리얼 스마트포인터 라이브러리는 다음과 같은 성능상의 이점을 갖는다.\n모든 연산이 상수시간에 수행된다. (Shipping 빌드 시) 대부분의 스마트포인터에서의 Dereferencing 시간은 cpp의 기본 포인터만큼 빠르다. 스마트포인터의 복사는 새로운 메모리 할당을 요구하지 않는다. 스레드 안전 스마트포인터는 lock을 걸지 않는다. 다만 다음과 같은 결점 또한 존재한다.\n새로운 스마트포인터 생성 및 복사는 cpp 기본 포인터보다 오버헤드가 존재한다. 참조카운트를 관리하기에 기본 연산 시 연산 주기가 추가된다. 몇몇의 스마트포인터는 cpp 기본 포인터보다 많은 메모리를 사용한다. 참조 제어자는 두 번의 힙 메모리 할당을 필요로 한다. MakeSharable 대신 MakeShared를 사용하는 경우 두번째 메모리 할당을 피할 수 있다. Intrusive Accessors 일반적으로 스마트포인터가 참조하고 있는 인스턴스는 자신을 소유하고 있는 스마트포인터의 존재를 인지하지 못한다.(이를 non-intrusive라고 부름) 그러나 언리얼의 스마트포인터 라이브러리는 TSharedFromThis를 통해 자신을 참조하는 스마트포인터에 대한 접근자를 얻을 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class FRegistryObject; class FMyBaseClass: public TSharedFromThis\u0026lt;FMyBaseClass\u0026gt; { virtual void RegisterAsBaseClass(FRegistryObject* RegistryObject) { // Access a shared reference to \u0026#39;this\u0026#39;. // We are directly inherited from \u0026lt;TSharedFromThis\u0026gt; , so AsShared() and SharedThis(this) return the same type. TSharedRef\u0026lt;FMyBaseClass\u0026gt; ThisAsSharedRef = AsShared(); // RegistryObject expects a TSharedRef\u0026lt;FMyBaseClass\u0026gt;, or a TSharedPtr\u0026lt;FMyBaseClass\u0026gt;. TSharedRef can implicitly be converted to a TSharedPtr. RegistryObject-\u0026gt;Register(ThisAsSharedRef); } }; class FMyDerivedClass : public FMyBaseClass { virtual void Register(FRegistryObject* RegistryObject) override { // We are not directly inherited from TSharedFromThis\u0026lt;\u0026gt;, so AsShared() and SharedThis(this) return different types. // AsShared() will return the type originally specified in TSharedFromThis\u0026lt;\u0026gt; - TSharedRef\u0026lt;FMyBaseClass\u0026gt; in this example. // SharedThis(this) will return a TSharedRef with the type of \u0026#39;this\u0026#39; - TSharedRef\u0026lt;FMyDerivedClass\u0026gt; in this example. // The SharedThis() function is only available in the same scope as the \u0026#39;this\u0026#39; pointer. TSharedRef\u0026lt;FMyDerivedClass\u0026gt; AsSharedRef = SharedThis(this); // RegistryObject will accept a TSharedRef\u0026lt;FMyDerivedClass\u0026gt; because FMyDerivedClass is a type of FMyBaseClass. RegistryObject-\u0026gt;Register(ThisAsSharedRef); } }; class FRegistryObject { // This function will accept a TSharedRef or TSharedPtr to FMyBaseClass or any of its children. void Register(TSharedRef\u0026lt;FMyBaseClass\u0026gt;); }; 앞서 언급했듯이 TSharedFromThis를 상속받음으로서 해당 클래스는 AsShared 메서드와 SharedThis를 사용하여 자신의 인스턴스를 참조하는 스마트포인터(TSharedRef)를 얻을 수 있다. 다만 SharedRef 메서드의 경우 파라미터로 this를 받기 때문에, TSharedFromThis를 직접 상속하지 않는 클래스의 경우에는 반환값이 달라진다. 만약 쉐어드 레퍼런스를 반환하는 팩토리 클래스 혹은 쉐어드 레퍼런스(또는 포인터)를 파라미터로 갖는 메서드의 경우(위 예시에서의 FRegistryObject::Register(TSharedRef\u0026lt;FMyBaseClass\u0026gt;)), TSharedFromThis를 직접 상속하는 base class의 쉐어드 포인터를 파라미터 타입으로 설정하는 것이 좋다.\nAsShared 와 SharedThis는 인스턴스화 된 오브젝트의 스마트포인터를 반환하기 때문에, 생성자에서 사용하게되면 crash나 assert를 유발함에 주의\n타입캐스팅 언리얼 스마트포인트 라이브러리는 cpp의 포인터와 유사한 방식으로 캐스팅을 할 수 있다.\nUp Casting : cpp의 기본 포인터와 유사하게 암묵적으로 수행된다.(기본 클래스의 포인터를 파생 클래스의 포인터로 자동으로 변환할 수 있다.) Const Casting : ConstCastSharedPtr/Ref 메서드를 이용해 수행. Static Casting : StaticCastSharedPtr/Ref 메서드를 이용해 수행(주로 다운캐스팅이다). Dynamic Casting : 런타임 타입 정보(RTTI)가 없기 때문에 동적캐스팅은 지원되지 않는다. 1 2 3 4 5 6 TSharedPtr\u0026lt;FDragDropOperation\u0026gt; Operation = DragDropEvent.GetOperation(); // Some code for validating that the FDragDropOperation is actually an FAssetDragDropOp through other means... // We can now cast with StaticCastSharedPtr. TSharedPtr\u0026lt;FAssetDragDropOp\u0026gt; DragDropOp = StaticCastSharedPtr\u0026lt;FAssetDragDropOp\u0026gt;(Operation); 스레드 안정성 디폴트로 스마트포인터는 싱글스레드 환경에서만 안전하다. 스레드 세이프한 버전을 원한다면 다음과 같은 클래스들을 사용하면 된다.\nTSharedPtr\u0026lt;T, ESPMode::ThreadSafe\u0026gt; TSharedRef\u0026lt;T, ESPMode::ThreadSafe\u0026gt; TWeakPtr\u0026lt;T, ESPMode::ThreadSafe\u0026gt; TSharedFromThis\u0026lt;T, ESPMode::ThreadSafe\u0026gt; 이 클래스들은 레퍼런스 카운트에 대한 원자적 연산을 수행하기 때문에 디폴트 클래스들보다 약간 느리지만, 동작 과정은 cpp 기본 포인터와 매우 유사하다.\n읽기와 복사 연산은 항상 스레드 안전하다 쓰기와 리셋 연산은 안정성을 위해 반드시 동기화되어야한다. 첨언 쉐어드 포인터/레퍼런스를 메서드의 인자로 넘기는 경우 레퍼런스 카운팅 및 Dereferencing에 의한 오버헤드가 존재한다. 가능하다면 const \u0026amp;로 넘겨주자 쉐어드 포인터의 경우 불완전한 클래스에 대한 전방선언을 하는 것이 가능하다. 앞서 언급했듯, 스마트포인터와 가비지 컬렉션(UObject Handling)은 완전히 분리된 메모리 관리 시스템이다. 전방선언 예시\n1 2 3 4 5 6 7 8 // 전방 선언 class IncompleteType; // 전방 선언된 타입에 대한 스마트 포인터 TSharedPtr\u0026lt;IncompleteType\u0026gt; incompleteTypePtr; // 나중에 IncompleteType의 정의가 완료되면 해당 타입으로 스마트 포인터를 생성할 수 있음 TSharedPtr\u0026lt;IncompleteType\u0026gt; incompleteTypePtr2 = MakeShared\u0026lt;IncompleteType\u0026gt;(); ","date":"2024-03-05T17:31:11+09:00","image":"https://sangho0n.github.io/ko/p/%EC%96%B8%EB%A6%AC%EC%96%BC-%EC%8A%A4%EB%A7%88%ED%8A%B8-%ED%8F%AC%EC%9D%B8%ED%84%B0/img/unreal.svg","permalink":"https://sangho0n.github.io/ko/p/%EC%96%B8%EB%A6%AC%EC%96%BC-%EC%8A%A4%EB%A7%88%ED%8A%B8-%ED%8F%AC%EC%9D%B8%ED%84%B0/","title":"언리얼 스마트 포인터"},{"content":"정렬 알고리즘은 최적, 평균, 최악 조건에서의 시간복잡도는 물론, 메모리 사용이나 안정성 등의 범주를 기준으로 골라서 써야 한다. 비교를 기반으로 하는 정렬 알고리즘의 최악 조건의 속도는 절대 O(nlog(n))보다 빠를 수 없다.\n이 포스트에서 다룰 정렬 알고리즘 목록 선택 정렬(Selection Sort) 삽입 정렬(Insertion Sort) 버블 정렬(Bubble Sort) 힙 정렬(Heap Sort) 퀵 정렬(Quick Sort) 합병 정렬(Merge Sort) 기수 정렬(Radix Sort) 선택 정렬 가장 단순한 알고리즘 중 하나. In-place 알고리즘이기에 복사 연산이 매우 느린 환경에 적합하다.\n매 단계마다 배열을 1번씩 스캔하며, 정렬이 되지 않은 원소 중 최솟값(최댓값)을 선택하여 맨 앞 원소와 swap한다\n해당 단계가 끝나면 정렬이 되지 않은 원소의 개수를 1개 줄이고, 줄어든 배열에 대해 같은 연산을 반복한다.\nIn-Place. Unstable.\n시간복잡도 Case 복잡도 최선 O(n2) 최악 O(n2) 평균 O(n2) 삽입 정렬 한 배열을 정렬이 된 배열과 안된 배열로 나누어, 단계마다 정렬이 된 배열은 크기를 늘리고 그렇지 않은 배열은 크기를 줄여가며 정렬.\n정렬이 되지 않은 배열 중 가장 앞 원소를, 정렬이 된 배열의 원소와 하나씩 순차적으로 비교하여 적절한 위치에 삽입한다.\nIn-Place. Stable.\n시간복잡도 Case 복잡도 최선(이미 정렬되어있는 경우) O(n) 최악 O(n2) 평균 O(n2) 버블 정렬 실린더에서 공깃방울이 떠오르듯 매 단계마다 배열을 선형탐색하여 인접한 원소와의 비교 및 swap연산을 진행.\nIn-place. Stable.\n시간복잡도 Case 복잡도 최선 O(n2) 최악 O(n2) 평균 O(n2) 힙 정렬 최대힙 혹은 최소힙을 이용하여 정렬하는 방법. 별도의 힙을 사용할 수도 있고, 주어진 배열을 Heap으로 만드는 것(In-place)도 가능하다.\n힙에 원소를 삽입/삭제하는 연산은 O(logn)(힙(완전이진트리)의 높이)이고 이 연산을 원소의 개수만큼 반복하므로(2번; Heap 만들기 + Heap에서 원소 하나씩 빼기) 전체 시간복잡도는 O(nlogn)\nIn-place. Unstable.\n시간복잡도 Case 복잡도 최선 O(nlogn) 최악 O(nlogn) 평균 O(nlogn) 퀵 정렬 피벗(Pivot)값을 기준으로 왼쪽에는 작은값, 오른쪽에는 큰값을 두고\n나눠진 배열에 대해서도 퀵정렬 각각 퀵정렬을 수행(더이상 나눌 수 없을 때까지)\nPivot이 매 순간마다 최적으로 선정된다면 주어진 배열은 매번 정확히 반으로 나누어진다. 최악의 경우는 Pivot이 매번 최솟값(혹은 최댓값)으로 선정되는 것과 같다.\nIn-place. Unstable.\n시간복잡도 Case 복잡도 최선 O(nlogn) 최악 O(n2) 평균 O(nlogn) 합병 정렬 분할정복형 알고리즘의 하나. 배열을 반으로 나누고 나눠진 각 배열에 대해 다시 합병 정렬을 수행. 이후 정렬이 된 배열들을 합쳐가면서 정렬이 된 하나의 큰 배열을 얻는 방법이다.\n다른 정렬 알고리즘들과 다르게 최선의 경우에도 O(n) 수준의 공간복잡도.\n나눠진 배열을 정렬함에 있어서 최적화를 위해 특정 크기를 기준으로 합병정렬이 아닌 다른 정렬 알고리즘(삽입정렬 등)을 혼합하여 사용할 수도 있다(이 경우 Stable하지 않을 수 있음).\nnot In-place. Stable.\n시간복잡도 Case 복잡도 최선 O(nlogn) 최악 O(nlogn) 평균 O(nlogn) 기수 정렬 앞선 알고리즘들과 달리 비교 없이 수행하는 정렬 알고리즘. 기수들을 기준으로 정렬하므로, 기수들은 사전순으로 정렬할 수 있어야 한다.\n버킷정렬의 일종.\nnot In-place. Stable\n시간복잡도 n을 정렬할 숫자의 개수, d를 최대 자리수, k를 버킷의 수(숫자의 경우 0~9이므로 10)라고 했을 때\n최선 최악 평균 모두 O(d(n + k))\n","date":"2024-02-26T11:49:35+09:00","image":"https://sangho0n.github.io/ko/p/%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B0%84%EB%8B%A8-%EC%A0%95%EB%A6%AC/img/algorithm_hu8666b0214ef6ef8b40207752073739fc_14421_120x120_fill_box_smart1_3.png","permalink":"https://sangho0n.github.io/ko/p/%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B0%84%EB%8B%A8-%EC%A0%95%EB%A6%AC/","title":"정렬 알고리즘 간단 정리"},{"content":"\n언리얼 엔진 5버전부터는 기존의 입력 맵핑 시스템이 deprecated 되었다. 이를 대체하는 Enhanced Input에 대해 알아보도록 하자.\n복잡한 입력 처리, 런타임 컨트롤 리맵핑 등을 효과적으로 지원하기 위해 UE5부터 등장한 개념이다. UE4의 디폴트 인풋 시스템의 업그레이드 버전이지만, 하위 호환성 역시 제공한다. 입력 데이터 처리뿐만 아니라 방사형 데스 존, 복합 액션, 콤보공격 등과 같은 기능들을 에셋 베이스 환경에서 구현할 수 있다.\n핵심 개념 Enhanced Input 시스템은 다음 네 가지의 핵심 개념을 갖는다.\nInput Action : Enhanced Input 시스템과 프로젝트 코드 간의 연결 통로. 인풋 액션은 자기 자신을 트리거한 입력과는 별개로 최대 3개의 독립적인 축(floating point)의 값을 알릴 수 있다. Input Mapping Context : 유저의 인풋을 인풋액션에 맵핑하는 역할 수행. 사용자별로 동적으로 추가하거나 삭제할 수 있으며, 우선순위를 가질 수도 있다. 하나 이상의 인풋 맵핑 컨텍스트를 플레이어에 적용하고 우선순위를 매기면, 여러 액션들이 동일한 입력에 의해 트리거되더라도 충돌을 해결할 수 있다. ex) 문 여는 버튼과 가방을 여는 버튼이 같은 경우\n한편 아래의 두 개념은 입력 처리를 더욱 유연하게 만드는 데 도움을 주는 요소들이다.\nModifier : 입력값을 다듬을 때 사용. 데드존을 적용하여 미세한 움직임에는 반응하지 않게 하거나, 입력값을 부드럽게 만드는 등의 작업을 수행한다. 이미 정의되어있는 모디파이어를 사용할 수도 있고, 개발자가 직접 정의할 수도 있다. Trigger : 모디파이어에 의해 가공된 데이터 혹은 다른 인풋 액션의 결괏값을 토대로 해당 인풋 액션을 활성화할지 결정. Input Actions Enhacned Input 시스템과 프로젝트 코드를 연결하는 역할. 인풋 액션을 트리거하기 위해서는 인풋 맵핑 컨텍스트에 해당 인풋 액션을 추가하고, 인풋 맵핑 컨텍스트를 로컬 플레이어의 Enhanced Input Local Player Subsystem에 등록해야한다.\n트리거된 인풋 액션에 Pawn이 반응하게 하기 위해서는 블루프린트를 이용하거나 cpp에서 이를 제어해야 한다.\n1 2 3 4 5 6 7 8 9 10 11 12 void AMyCharacter::SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) { Super::SetupPlayerInputComponent(PlayerInputComponent); UEnhancedInputComponent* EnhancedInputComponent = CastChecked\u0026lt;UEnhancedInputComponent\u0026gt;(PlayerInputComponent); EnhancedInputComponent-\u0026gt;BindAction(MyAction, ETriggerEvent::Triggered, this, \u0026amp;AMyCharacter::MyAction); } void AMyCharacter::MyAction(const FInputActionValue\u0026amp; Value) { // do sth } Input Mapping Contexts 인풋 맵핑 컨텍스트에서는 입력과 인풋 액션을 맵핑시킬 수 있다. 맵핑이 완료된 컨텍스트는 로컬 플레이어의 Enhanced Input Local Player Subsystem에 언제든 추가/삭제할 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 // do sth ... APlayerController* PlayerController = CastChecked\u0026lt;APlayerController\u0026gt;(GetController()); if (UEnhancedInputLocalPlayerSubsystem* Subsystem = ULocalPlayer::GetSubsystem\u0026lt;UEnhancedInputLocalPlayerSubsystem\u0026gt;(PlayerController-\u0026gt;GetLocalPlayer())) { Subsystem-\u0026gt;ClearAllMappings(); UInputMappingContext* NewMappingContext = NewCharacterControl-\u0026gt;InputMappingContext; if (NewMappingContext) { Subsystem-\u0026gt;AddMappingContext(NewMappingContext, 0); } } // do sth ... Modifier 모디파이어는 트리거로 입력 값을 보내기 전 이를 조절할 수 있는 프리 프로세서이다. 언리얼 엔진은 아래의 모디파이어를 기본적으로 제공한다.\n모디파이어를 새로 생성하려면 먼저 InputModifier 클래스를 상속받는 클래스를 만들어야 한다. 그리고 Modify Raw 함수를 오버라이드한다. 방향 입력 모디파이어의를 적절히 사용한 사례로 하나의 입력 액션을 활용한 2차원 방향 입력을 들 수 있다. 3인칭 템플릿 프로젝트 생성 시, IA_Move와 IMC_Default를 살펴보면 아래와 같이 설정되어 있는 것을 확인할 수 있다.\n문자 키 방향키 스칼라값 모디파이어 원하는 방향 벡터 w 위 1 Swizzle Input Axis Value (1, 0, 0) s 아래 1 Swizzle Input Axis Value, Negate (-1, 0, 0) a 왼쪽 1 Negate (0, -1, 0) d 오른쪽 1 - (0, 1, 0) UInputModifierSwizzleAxis 모디파이어의 선언부와 구현부 일부를 보면 다음과 같은 것을 확인할 수 있는데,\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 /** Swizzle axis components of an input value. * Useful to map a 1D input onto the Y axis of a 2D action. */ UCLASS(NotBlueprintable, MinimalAPI, meta = (DisplayName = \u0026#34;Swizzle Input Axis Values\u0026#34;)) class UInputModifierSwizzleAxis : public UInputModifier { GENERATED_BODY() public: // Default to XY swap, useful for binding 1D inputs to the Y axis. UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Settings) EInputAxisSwizzle Order = EInputAxisSwizzle::YXZ; protected: virtual FInputActionValue ModifyRaw_Implementation(const UEnhancedPlayerInput* PlayerInput, FInputActionValue CurrentValue, float DeltaTime) override; virtual FLinearColor GetVisualizationColor_Implementation(FInputActionValue SampleValue, FInputActionValue FinalValue) const override; }; FInputActionValue UInputModifierSwizzleAxis::ModifyRaw_Implementation(const UEnhancedPlayerInput* PlayerInput, FInputActionValue CurrentValue, float DeltaTime) { FVector Value = CurrentValue.Get\u0026lt;FVector\u0026gt;(); switch (Order) { case EInputAxisSwizzle::YXZ: Swap(Value.X, Value.Y); break; case EInputAxisSwizzle::ZYX: Swap(Value.X, Value.Z); break; case EInputAxisSwizzle::XZY: Swap(Value.Y, Value.Z); break; case EInputAxisSwizzle::YZX: Value = FVector(Value.Y, Value.Z, Value.X); break; case EInputAxisSwizzle::ZXY: Value = FVector(Value.Z, Value.X, Value.Y); break; } return FInputActionValue(CurrentValue.GetValueType(), Value); } Order가 default로 YXZ이므로 위 스칼라값인 1을 모디파이어를 통과시키면 (1.0f, 0.0f, 0.0f)의 값을 가지게 된다. 따라서 위의 표와 같이 모디파이어를 설정하면 스칼라값들을 원하는 방향 벡터로 변환시킬 수 있게 되는 것이다.\nTrigger 트리거는 모디파이어 리스트를 통과한 값을 확인 후, 해당 값이 액션을 활성화시킬 수 있는지 여부를 결정한다. 다만 예외적으로 Chored Action 트리거는 다른 인풋 액션을 통해서 트리거된다. 아래 사진은 기본 트리거들이다.\n트리거 타입에는 Explicit, Implicit, Blocker 3가지가 있다.\nExplicit : 트리거 성공 시, 입력 성공 Implicit : 트리거 성공 + 모든 암시 타입의 트리거 성공 시, 입력 성공 Blocker : 트리거 성공 시, 입력 실패 아래의 표는 트리거 유형에 따른 타입이다.\n트리거 클래스(cpp) 타입 UInputTrigger(default) ETriggerType::Explicit UInputTriggerCombo ETriggerType::Implicit UInputTriggerChordAction ETriggerType::Implicit UInputTriggerChordBlocker ETriggerType::Blocker 한편 사용자 입력을 처리하고 나면 트리거는 다음 세 개의 상태 중 하나를 반환할 수 있다.\nNone : 조건이 충족되지 않아 트리거에 실패함 Ongoing : 조건이 부분적으로 충족되었으며 트리거가 처리 중이지만 아직 성공하지 않음을 의미 Triggered : 모든 입력 트리거 조건이 충족되었고 입력 트리거가 성공함 InputTrigger 클래스 혹은 InputTriggerTimedBase 클래스를 상속하면 커스텀 트리거를 생성할 수 있다. InputTriggerTimedBase는 특정 시간 동안 입력이 지속되었는지 확인하고, 지속되는 동안 Ongoing 상태를 반환한다. 다만 기본적으로 InputTriggerTimedBase는 조건이 충족되어도 Triggered를 반환하지 않기 때문에, 해당 클래스를 상속받아 새로운 트리거를 만들었다면 GetTriggerType과 UpdateState 메서드를 오버라이드하여 원하는 상태를 반환토록 해야한다.\n","date":"2024-02-14T17:44:19+09:00","image":"https://sangho0n.github.io/ko/p/%EC%96%B8%EB%A6%AC%EC%96%BC-enhanced-input/img/unreal.svg","permalink":"https://sangho0n.github.io/ko/p/%EC%96%B8%EB%A6%AC%EC%96%BC-enhanced-input/","title":"언리얼 Enhanced Input"},{"content":"이득우 님의 강의 와 다른 개발자가 정리해놓은 문서를 보고 정리한 내용입니다.\n자세하고 정확한 내용은 위 링크를 참조하세요\n시리즈\n언리얼 GAS 개요 \u0026lt;- 현재포스트 언리얼 GAS 시작 게임플레이 어빌리티 시스템 액터의 어빌리티 및 어빌리티를 통한 액터 간 상호작용 기능을 제공하는 프레임워크 장점 유연성, 확장성 : 다양하고 복잡한 게임 제작에 쉽게 활용할 수 있다. 모듈러 시스템 : 각 기능에 대한 의존성 최소화 네트워크 지원 데이터 기반 설계 완성도 : 포트나이트 등의 게임이 이미 이를 활용하고 있음 단점 학습 비용 소규모 프로젝트에서의 오버헤드 큰 규모의 RPG 및 멀티플레이 게임을 만들기에 적합함\n구성 요소 게임플레이 어빌리티 : 비용 및 쿨타임(optional) 기반의 캐릭터 어빌리티 구현 어트리뷰트 : 액터의 특성 조작 게임플레이 이펙트 : 어빌리티 발동에 따른 액터의 상태 변경 게임플레이 태그 : 액터에 대한 태그 지정 게임플레이 큐 : 시청각효과 위 모든 것들에 대한 레플리케이션 멀티플레이 게임에서의 GAS GAS 플러그인은 다음과 같은 client-side-prediction(서버의 허가 없이 어빌리티 발동 및 이펙트를 적용하는 것)을 지원한다.\n어빌리티 발동 애니메이션 몽타주 재생 어트리뷰트 변경 게임플레이 태그 지정 게임플레이 큐 실행 CharacterMovementComponent와 연결된 RootMotionSource functions를 통한 움직임 조작 블루프린트 vs C++ GAS는 cpp을 사용하여 구현되어야 하지만, GameplayAbilities와 GameplayEffects에 한하여 블루프린트로 구현이 가능하다.\n","date":"2024-02-14T13:53:44+09:00","image":"https://sangho0n.github.io/ko/p/%EC%96%B8%EB%A6%AC%EC%96%BC-gas-%EA%B0%9C%EC%9A%94/img/unreal.svg","permalink":"https://sangho0n.github.io/ko/p/%EC%96%B8%EB%A6%AC%EC%96%BC-gas-%EA%B0%9C%EC%9A%94/","title":"언리얼 GAS 개요"}]